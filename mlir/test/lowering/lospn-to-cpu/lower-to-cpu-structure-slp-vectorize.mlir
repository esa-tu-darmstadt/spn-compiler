// RUN: %optcall -pass-pipeline="builtin.module(convert-lospn-structure-to-cpu{vectorize=true vector-width=4 slp-max-attempts=1 slp-max-successful-iterations=1 slp-max-node-size=10 slp-max-look-ahead=5 slp-reorder-instructions-dfs=true slp-allow-duplicate-elements=false slp-allow-topological-mixing=false slp-use-xor-chains=true})" %s | FileCheck %s
// Test (re)generated by regenerate_tests.py.
module {
  "lo_spn.kernel"() <{function_type = (memref<?x4xi32>, memref<1x?xf64>) -> (), sym_name = "spn_cpu"}> ({
  ^bb0(%arg0: memref<?x4xi32>, %arg1: memref<1x?xf64>):
    %c0 = arith.constant 0 : index
    %dim = memref.dim %arg0, %c0 : memref<?x4xi32>
    %alloc = memref.alloc(%dim) : memref<1x?xf64>
    "lo_spn.task"(%arg0, %alloc) <{batchSize = 1 : ui32}> ({
    ^bb0(%arg2: index, %arg3: memref<?x4xi32>, %arg4: memref<1x?xf64>):
      %0 = "lo_spn.batch_read"(%arg3, %arg2) <{staticIndex = 3 : ui32}> : (memref<?x4xi32>, index) -> i32
      %1 = "lo_spn.batch_read"(%arg3, %arg2) <{staticIndex = 2 : ui32}> : (memref<?x4xi32>, index) -> i32
      %2 = "lo_spn.batch_read"(%arg3, %arg2) <{staticIndex = 1 : ui32}> : (memref<?x4xi32>, index) -> i32
      %3 = "lo_spn.batch_read"(%arg3, %arg2) <{staticIndex = 0 : ui32}> : (memref<?x4xi32>, index) -> i32
      %4 = "lo_spn.body"(%0, %1, %2, %3) ({
      ^bb0(%arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32):
        %5 = "lo_spn.gaussian"(%arg5) <{mean = 1.100000e-01 : f64, stddev = 1.000000e+00 : f64, supportMarginal = false}> : (i32) -> f64
        %6 = "lo_spn.gaussian"(%arg6) <{mean = 1.200000e-01 : f64, stddev = 7.500000e-01 : f64, supportMarginal = false}> : (i32) -> f64
        %7 = "lo_spn.gaussian"(%arg7) <{mean = 1.300000e-01 : f64, stddev = 5.000000e-01 : f64, supportMarginal = false}> : (i32) -> f64
        %8 = "lo_spn.gaussian"(%arg8) <{mean = 1.400000e-01 : f64, stddev = 2.500000e-01 : f64, supportMarginal = false}> : (i32) -> f64
        %9 = "lo_spn.constant"() <{value = 1.000000e+00 : f64}> : () -> f64
        %10 = "lo_spn.constant"() <{value = 2.000000e+00 : f64}> : () -> f64
        %11 = "lo_spn.constant"() <{value = 3.000000e+00 : f64}> : () -> f64
        %12 = "lo_spn.constant"() <{value = 4.000000e+00 : f64}> : () -> f64
        %cst = arith.constant 5.000000e+00 : f64
        %cst_0 = arith.constant 6.000000e+00 : f64
        %cst_1 = arith.constant 7.000000e+00 : f64
        %cst_2 = arith.constant 8.000000e+00 : f64
        %13 = "lo_spn.mul"(%5, %9) : (f64, f64) -> f64
        %14 = "lo_spn.mul"(%10, %6) : (f64, f64) -> f64
        %15 = "lo_spn.mul"(%cst_1, %7) : (f64, f64) -> f64
        %16 = "lo_spn.mul"(%8, %cst_2) : (f64, f64) -> f64
        %17 = "lo_spn.mul"(%13, %cst) : (f64, f64) -> f64
        %18 = "lo_spn.mul"(%14, %cst_0) : (f64, f64) -> f64
        %19 = "lo_spn.mul"(%15, %11) : (f64, f64) -> f64
        %20 = "lo_spn.mul"(%16, %12) : (f64, f64) -> f64
        %cst_3 = arith.constant 2.500000e-01 : f64
        %21 = "lo_spn.mul"(%17, %cst_3) : (f64, f64) -> f64
        %22 = "lo_spn.mul"(%18, %cst_3) : (f64, f64) -> f64
        %23 = "lo_spn.mul"(%19, %cst_3) : (f64, f64) -> f64
        %24 = "lo_spn.mul"(%20, %cst_3) : (f64, f64) -> f64
        %25 = "lo_spn.add"(%21, %22) : (f64, f64) -> f64
        %26 = "lo_spn.add"(%23, %24) : (f64, f64) -> f64
        %27 = "lo_spn.add"(%25, %26) : (f64, f64) -> f64
        %28 = "lo_spn.log"(%27) : (f64) -> f64
        "lo_spn.yield"(%28) : (f64) -> ()
      }) : (i32, i32, i32, i32) -> f64
      "lo_spn.batch_write"(%arg4, %arg2, %4) <{transposed = true}> : (memref<1x?xf64>, index, f64) -> ()
      "lo_spn.return"() : () -> ()
    }) : (memref<?x4xi32>, memref<1x?xf64>) -> ()
    "lo_spn.copy"(%alloc, %arg1) : (memref<1x?xf64>, memref<1x?xf64>) -> ()
    "lo_spn.return"() : () -> ()
  }) {type = (memref<?x4xi32>, memref<1x?xf64>) -> ()} : () -> ()
}

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// The script is designed to make adding checks to
// a test case fast, it is *not* designed to be authoritative
// about what constitutes a good test! The CHECK should be
// minimized and named to reflect the test intent.



// CHECK-LABEL:   func.func @vec_task_0(
// CHECK-SAME:                          %[[VAL_0:.*]]: memref<?x4xi32>,
// CHECK-SAME:                          %[[VAL_1:.*]]: memref<1x?xf64>) {
// CHECK:           %[[VAL_2:.*]] = arith.constant 3 : i32
// CHECK:           %[[VAL_3:.*]] = arith.constant 2 : i32
// CHECK:           %[[VAL_4:.*]] = arith.constant 1 : i32
// CHECK:           %[[VAL_5:.*]] = arith.constant 0 : i32
// CHECK:           %[[VAL_6:.*]] = arith.constant dense<[2.500000e-01, 2.500000e-01, 2.500000e-01, 5.000000e+00]> : vector<4xf64>
// CHECK:           %[[VAL_7:.*]] = arith.constant dense<[4.000000e+00, 3.000000e+00, 6.000000e+00, 2.500000e-01]> : vector<4xf64>
// CHECK:           %[[VAL_8:.*]] = arith.constant dense<[8.000000e+00, 7.000000e+00, 2.000000e+00, 1.000000e+00]> : vector<4xf64>
// CHECK:           %[[VAL_9:.*]] = arith.constant dense<[0.62665706865775006, 1.2533141373155001, 1.8799712059732503, 2.5066282746310002]> : vector<4xf64>
// CHECK:           %[[VAL_10:.*]] = arith.constant dense<[-1.250000e-01, -5.000000e-01, -1.125000e+00, -2.000000e+00]> : vector<4xf64>
// CHECK:           %[[VAL_11:.*]] = arith.constant dense<[1.400000e-01, 1.300000e-01, 1.200000e-01, 1.100000e-01]> : vector<4xf64>
// CHECK:           %[[VAL_12:.*]] = arith.constant 0 : index
// CHECK:           %[[VAL_13:.*]] = arith.constant 0 : index
// CHECK:           %[[VAL_14:.*]] = vector.load %[[VAL_0]]{{\[}}%[[VAL_13]], %[[VAL_12]]] : memref<?x4xi32>, vector<4xi32>
// CHECK:           %[[VAL_15:.*]] = arith.uitofp %[[VAL_14]] : vector<4xi32> to vector<4xf64>
// CHECK:           %[[VAL_16:.*]] = arith.subf %[[VAL_15]], %[[VAL_11]] : vector<4xf64>
// CHECK:           %[[VAL_17:.*]] = arith.mulf %[[VAL_16]], %[[VAL_16]] : vector<4xf64>
// CHECK:           %[[VAL_18:.*]] = arith.divf %[[VAL_17]], %[[VAL_10]] : vector<4xf64>
// CHECK:           %[[VAL_19:.*]] = math.exp %[[VAL_18]] : vector<4xf64>
// CHECK:           %[[VAL_20:.*]] = arith.divf %[[VAL_19]], %[[VAL_9]] : vector<4xf64>
// CHECK:           %[[VAL_21:.*]] = arith.mulf %[[VAL_8]], %[[VAL_20]] : vector<4xf64>
// CHECK:           %[[VAL_22:.*]] = arith.mulf %[[VAL_21]], %[[VAL_7]] : vector<4xf64>
// CHECK:           %[[VAL_23:.*]] = arith.mulf %[[VAL_22]], %[[VAL_6]] : vector<4xf64>
// CHECK:           %[[VAL_24:.*]] = vector.extractelement %[[VAL_23]]{{\[}}%[[VAL_2]] : i32] : vector<4xf64>
// CHECK:           %[[VAL_25:.*]] = vector.extractelement %[[VAL_23]]{{\[}}%[[VAL_3]] : i32] : vector<4xf64>
// CHECK:           %[[VAL_26:.*]] = vector.extractelement %[[VAL_23]]{{\[}}%[[VAL_4]] : i32] : vector<4xf64>
// CHECK:           %[[VAL_27:.*]] = vector.extractelement %[[VAL_23]]{{\[}}%[[VAL_5]] : i32] : vector<4xf64>
// CHECK:           %[[VAL_28:.*]] = "lo_spn.add"(%[[VAL_24]], %[[VAL_25]]) : (f64, f64) -> f64
// CHECK:           %[[VAL_29:.*]] = "lo_spn.add"(%[[VAL_26]], %[[VAL_27]]) : (f64, f64) -> f64
// CHECK:           %[[VAL_30:.*]] = "lo_spn.add"(%[[VAL_28]], %[[VAL_29]]) : (f64, f64) -> f64
// CHECK:           %[[VAL_31:.*]] = "lo_spn.log"(%[[VAL_30]]) : (f64) -> f64
// CHECK:           "lo_spn.batch_write"(%[[VAL_1]], %[[VAL_13]], %[[VAL_31]]) <{transposed = true}> : (memref<1x?xf64>, index, f64) -> ()
// CHECK:           "lo_spn.return"() : () -> ()
// CHECK:         }

// CHECK-LABEL:   func.func @spn_cpu(
// CHECK-SAME:                       %[[VAL_0:.*]]: memref<?x4xi32>,
// CHECK-SAME:                       %[[VAL_1:.*]]: memref<1x?xf64>) {
// CHECK:           %[[VAL_2:.*]] = arith.constant 0 : index
// CHECK:           %[[VAL_3:.*]] = memref.dim %[[VAL_0]], %[[VAL_2]] : memref<?x4xi32>
// CHECK:           %[[VAL_4:.*]] = memref.alloc(%[[VAL_3]]) : memref<1x?xf64>
// CHECK:           call @vec_task_0(%[[VAL_0]], %[[VAL_4]]) : (memref<?x4xi32>, memref<1x?xf64>) -> ()
// CHECK:           "lo_spn.copy"(%[[VAL_4]], %[[VAL_1]]) : (memref<1x?xf64>, memref<1x?xf64>) -> ()
// CHECK:           "lo_spn.return"() : () -> ()
// CHECK:         }

