// RUN: %optcall --convert-lospn-nodes-to-cpu %s | FileCheck %s

module  {
  func @task_0(%arg0: memref<?x6xf64>, %arg1: memref<?xf64>) {
    %c0 = constant 0 : index
    %c0_0 = constant 0 : index
    %0 = memref.dim %arg0, %c0_0 : memref<?x6xf64>
    %c1 = constant 1 : index
    scf.for %arg2 = %c0 to %0 step %c1 {
      %1 = "lo_spn.batch_read"(%arg0, %arg2) {sampleIndex = 0 : ui32} : (memref<?x6xf64>, index) -> f64
      %2 = "lo_spn.batch_read"(%arg0, %arg2) {sampleIndex = 1 : ui32} : (memref<?x6xf64>, index) -> f64
      %3 = "lo_spn.batch_read"(%arg0, %arg2) {sampleIndex = 2 : ui32} : (memref<?x6xf64>, index) -> f64
      %4 = "lo_spn.batch_read"(%arg0, %arg2) {sampleIndex = 3 : ui32} : (memref<?x6xf64>, index) -> f64
      %5 = "lo_spn.batch_read"(%arg0, %arg2) {sampleIndex = 4 : ui32} : (memref<?x6xf64>, index) -> f64
      %6 = "lo_spn.batch_read"(%arg0, %arg2) {sampleIndex = 5 : ui32} : (memref<?x6xf64>, index) -> f64
      %cst = constant 1.000000e-01 : f64
      %7 = "lo_spn.select"(%1) {input_true_threshold = 1.000000e+00 : f64, supportMarginal = false, val_false = 5.500000e-01 : f64, val_true = 3.500000e-01 : f64} : (f64) -> f64
      %8 = "lo_spn.categorical"(%2) {probabilities = [2.500000e-01, 6.250000e-01, 1.250000e-01], supportMarginal = false} : (f64) -> f64
      %9 = "lo_spn.select"(%3) {input_true_threshold = 1.000000e+00 : f64, supportMarginal = false, val_false = 7.500000e-01 : f64, val_true = 2.500000e-01 : f64} : (f64) -> f64
      %10 = "lo_spn.select"(%4) {input_true_threshold = 1.000000e+00 : f64, supportMarginal = false, val_false = 5.500000e-01 : f64, val_true = 4.500000e-01 : f64} : (f64) -> f64
      %11 = "lo_spn.gaussian"(%5) {mean = 5.000000e-01 : f64, stddev = 1.000000e+00 : f64, supportMarginal = false} : (f64) -> f64
      %12 = "lo_spn.gaussian"(%6) {mean = 2.500000e-01 : f64, stddev = 1.000000e-01 : f64, supportMarginal = false} : (f64) -> f64
      %13 = "lo_spn.mul"(%7, %8) : (f64, f64) -> f64
      %14 = "lo_spn.mul"(%13, %9) : (f64, f64) -> f64
      %15 = "lo_spn.mul"(%14, %cst) : (f64, f64) -> f64
      %16 = "lo_spn.mul"(%10, %11) : (f64, f64) -> f64
      %17 = "lo_spn.mul"(%16, %12) : (f64, f64) -> f64
      %18 = "lo_spn.mul"(%17, %cst) : (f64, f64) -> f64
      %19 = "lo_spn.add"(%15, %18) : (f64, f64) -> f64
      %20 = "lo_spn.log"(%19) : (f64) -> f64
      "lo_spn.batch_write"(%20, %arg1, %arg2) : (f64, memref<?xf64>, index) -> ()
    }
    return
  }
  func @spn_vector(%arg0: memref<?x6xf64>, %arg1: memref<?xf64>) {
    %c0 = constant 0 : index
    %0 = memref.dim %arg0, %c0 : memref<?x6xf64>
    %1 = memref.alloc(%0) : memref<?xf64>
    call @task_0(%arg0, %1) : (memref<?x6xf64>, memref<?xf64>) -> ()
    "lo_spn.copy"(%1, %arg1) : (memref<?xf64>, memref<?xf64>) -> ()
    "lo_spn.return"() : () -> ()
  }
}

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL:   memref.global "private" constant @categorical_0 : memref<3xf64> = dense<[2.500000e-01, 6.250000e-01, 1.250000e-01]>

// CHECK-LABEL:   func @task_0(
// CHECK-SAME:                 %[[VAL_0:.*]]: memref<?x6xf64>,
// CHECK-SAME:                 %[[VAL_1:.*]]: memref<?xf64>) {
// CHECK:           %[[VAL_2:.*]] = constant 0 : index
// CHECK:           %[[VAL_3:.*]] = constant 0 : index
// CHECK:           %[[VAL_4:.*]] = memref.dim %[[VAL_0]], %[[VAL_3]] : memref<?x6xf64>
// CHECK:           %[[VAL_5:.*]] = constant 1 : index
// CHECK:           scf.for %[[VAL_6:.*]] = %[[VAL_2]] to %[[VAL_4]] step %[[VAL_5]] {
// CHECK:             %[[VAL_7:.*]] = constant 0 : index
// CHECK:             %[[VAL_8:.*]] = memref.load %[[VAL_0]]{{\[}}%[[VAL_6]], %[[VAL_7]]] : memref<?x6xf64>
// CHECK:             %[[VAL_9:.*]] = constant 1 : index
// CHECK:             %[[VAL_10:.*]] = memref.load %[[VAL_0]]{{\[}}%[[VAL_6]], %[[VAL_9]]] : memref<?x6xf64>
// CHECK:             %[[VAL_11:.*]] = constant 2 : index
// CHECK:             %[[VAL_12:.*]] = memref.load %[[VAL_0]]{{\[}}%[[VAL_6]], %[[VAL_11]]] : memref<?x6xf64>
// CHECK:             %[[VAL_13:.*]] = constant 3 : index
// CHECK:             %[[VAL_14:.*]] = memref.load %[[VAL_0]]{{\[}}%[[VAL_6]], %[[VAL_13]]] : memref<?x6xf64>
// CHECK:             %[[VAL_15:.*]] = constant 4 : index
// CHECK:             %[[VAL_16:.*]] = memref.load %[[VAL_0]]{{\[}}%[[VAL_6]], %[[VAL_15]]] : memref<?x6xf64>
// CHECK:             %[[VAL_17:.*]] = constant 5 : index
// CHECK:             %[[VAL_18:.*]] = memref.load %[[VAL_0]]{{\[}}%[[VAL_6]], %[[VAL_17]]] : memref<?x6xf64>
// CHECK:             %[[VAL_19:.*]] = constant 1.000000e-01 : f64
// CHECK:             %[[VAL_20:.*]] = constant 1.000000e+00 : f64
// CHECK:             %[[VAL_21:.*]] = cmpf ult, %[[VAL_8]], %[[VAL_20]] : f64
// CHECK:             %[[VAL_22:.*]] = constant 3.500000e-01 : f64
// CHECK:             %[[VAL_23:.*]] = constant 5.500000e-01 : f64
// CHECK:             %[[VAL_24:.*]] = select %[[VAL_21]], %[[VAL_22]], %[[VAL_23]] : f64
// CHECK:             %[[VAL_25:.*]] = memref.get_global @categorical_0 : memref<3xf64>
// CHECK:             %[[VAL_26:.*]] = fptoui %[[VAL_10]] : f64 to i64
// CHECK:             %[[VAL_27:.*]] = index_cast %[[VAL_26]] : i64 to index
// CHECK:             %[[VAL_28:.*]] = memref.load %[[VAL_25]]{{\[}}%[[VAL_27]]] : memref<3xf64>
// CHECK:             %[[VAL_29:.*]] = constant 1.000000e+00 : f64
// CHECK:             %[[VAL_30:.*]] = cmpf ult, %[[VAL_12]], %[[VAL_29]] : f64
// CHECK:             %[[VAL_31:.*]] = constant 2.500000e-01 : f64
// CHECK:             %[[VAL_32:.*]] = constant 7.500000e-01 : f64
// CHECK:             %[[VAL_33:.*]] = select %[[VAL_30]], %[[VAL_31]], %[[VAL_32]] : f64
// CHECK:             %[[VAL_34:.*]] = constant 1.000000e+00 : f64
// CHECK:             %[[VAL_35:.*]] = cmpf ult, %[[VAL_14]], %[[VAL_34]] : f64
// CHECK:             %[[VAL_36:.*]] = constant 4.500000e-01 : f64
// CHECK:             %[[VAL_37:.*]] = constant 5.500000e-01 : f64
// CHECK:             %[[VAL_38:.*]] = select %[[VAL_35]], %[[VAL_36]], %[[VAL_37]] : f64
// CHECK:             %[[VAL_39:.*]] = constant 0.3989422804014327 : f64
// CHECK:             %[[VAL_40:.*]] = constant -5.000000e-01 : f64
// CHECK:             %[[VAL_41:.*]] = constant 5.000000e-01 : f64
// CHECK:             %[[VAL_42:.*]] = subf %[[VAL_16]], %[[VAL_41]] : f64
// CHECK:             %[[VAL_43:.*]] = mulf %[[VAL_42]], %[[VAL_42]] : f64
// CHECK:             %[[VAL_44:.*]] = mulf %[[VAL_43]], %[[VAL_40]] : f64
// CHECK:             %[[VAL_45:.*]] = math.exp %[[VAL_44]] : f64
// CHECK:             %[[VAL_46:.*]] = mulf %[[VAL_39]], %[[VAL_45]] : f64
// CHECK:             %[[VAL_47:.*]] = constant 3.9894228040143269 : f64
// CHECK:             %[[VAL_48:.*]] = constant -49.999999999999993 : f64
// CHECK:             %[[VAL_49:.*]] = constant 2.500000e-01 : f64
// CHECK:             %[[VAL_50:.*]] = subf %[[VAL_18]], %[[VAL_49]] : f64
// CHECK:             %[[VAL_51:.*]] = mulf %[[VAL_50]], %[[VAL_50]] : f64
// CHECK:             %[[VAL_52:.*]] = mulf %[[VAL_51]], %[[VAL_48]] : f64
// CHECK:             %[[VAL_53:.*]] = math.exp %[[VAL_52]] : f64
// CHECK:             %[[VAL_54:.*]] = mulf %[[VAL_47]], %[[VAL_53]] : f64
// CHECK:             %[[VAL_55:.*]] = mulf %[[VAL_24]], %[[VAL_28]] : f64
// CHECK:             %[[VAL_56:.*]] = mulf %[[VAL_55]], %[[VAL_33]] : f64
// CHECK:             %[[VAL_57:.*]] = mulf %[[VAL_56]], %[[VAL_19]] : f64
// CHECK:             %[[VAL_58:.*]] = mulf %[[VAL_38]], %[[VAL_46]] : f64
// CHECK:             %[[VAL_59:.*]] = mulf %[[VAL_58]], %[[VAL_54]] : f64
// CHECK:             %[[VAL_60:.*]] = mulf %[[VAL_59]], %[[VAL_19]] : f64
// CHECK:             %[[VAL_61:.*]] = addf %[[VAL_57]], %[[VAL_60]] : f64
// CHECK:             %[[VAL_62:.*]] = math.log %[[VAL_61]] : f64
// CHECK:             memref.store %[[VAL_62]], %[[VAL_1]]{{\[}}%[[VAL_6]]] : memref<?xf64>
// CHECK:           }
// CHECK:           return
// CHECK:         }

// CHECK-LABEL:   func @spn_vector(
// CHECK-SAME:                     %[[VAL_0:.*]]: memref<?x6xf64>,
// CHECK-SAME:                     %[[VAL_1:.*]]: memref<?xf64>) {
// CHECK:           %[[VAL_2:.*]] = constant 0 : index
// CHECK:           %[[VAL_3:.*]] = memref.dim %[[VAL_0]], %[[VAL_2]] : memref<?x6xf64>
// CHECK:           %[[VAL_4:.*]] = memref.alloc(%[[VAL_3]]) : memref<?xf64>
// CHECK:           call @task_0(%[[VAL_0]], %[[VAL_4]]) : (memref<?x6xf64>, memref<?xf64>) -> ()
// CHECK:           %[[VAL_5:.*]] = constant 0 : index
// CHECK:           %[[VAL_6:.*]] = memref.dim %[[VAL_4]], %[[VAL_5]] : memref<?xf64>
// CHECK:           %[[VAL_7:.*]] = constant 0 : index
// CHECK:           %[[VAL_8:.*]] = constant 1 : index
// CHECK:           scf.for %[[VAL_9:.*]] = %[[VAL_7]] to %[[VAL_6]] step %[[VAL_8]] {
// CHECK:             %[[VAL_10:.*]] = memref.load %[[VAL_4]]{{\[}}%[[VAL_9]]] : memref<?xf64>
// CHECK:             memref.store %[[VAL_10]], %[[VAL_1]]{{\[}}%[[VAL_9]]] : memref<?xf64>
// CHECK:           }
// CHECK:           return
// CHECK:         }
