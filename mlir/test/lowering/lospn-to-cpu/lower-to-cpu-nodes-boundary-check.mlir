// RUN: %optcall --convert-lospn-nodes-to-cpu %s | FileCheck %s

module  {
  func @task_0(%arg0: memref<?x1xi32>, %arg1: memref<?xf64>) {
    %c0 = constant 0 : index
    %c0_0 = constant 0 : index
    %0 = memref.dim %arg0, %c0_0 : memref<?x1xi32>
    %c1 = constant 1 : index
    scf.for %arg2 = %c0 to %0 step %c1 {
      %1 = "lo_spn.batch_read"(%arg0, %arg2) {sampleIndex = 0 : ui32} : (memref<?x1xi32>, index) -> i32
      %2 = "lo_spn.select"(%1) {input_true_threshold = 1.000000e+00 : f64, supportMarginal = false, val_false = 7.500000e-01 : f64, val_true = 2.500000e-01 : f64} : (i32) -> f64
      %3 = "lo_spn.log"(%2) : (f64) -> f64
      "lo_spn.batch_write"(%3, %arg1, %arg2) : (f64, memref<?xf64>, index) -> ()
    }
    return
  }
  func @spn_kernel(%arg0: memref<?x1xi32>, %arg1: memref<?xf64>) {
    %c0 = constant 0 : index
    %0 = memref.dim %arg0, %c0 : memref<?x1xi32>
    %1 = memref.alloc(%0) : memref<?xf64>
    call @task_0(%arg0, %1) : (memref<?x1xi32>, memref<?xf64>) -> ()
    "lo_spn.copy"(%1, %arg1) : (memref<?xf64>, memref<?xf64>) -> ()
    "lo_spn.return"() : () -> ()
  }
}

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py


// CHECK-LABEL:   func @task_0(
// CHECK-SAME:                 %[[VAL_0:.*]]: memref<?x1xi32>,
// CHECK-SAME:                 %[[VAL_1:.*]]: memref<?xf64>) {
// CHECK:           %[[VAL_2:.*]] = constant 0 : index
// CHECK:           %[[VAL_3:.*]] = constant 0 : index
// CHECK:           %[[VAL_4:.*]] = memref.dim %[[VAL_0]], %[[VAL_3]] : memref<?x1xi32>
// CHECK:           %[[VAL_5:.*]] = constant 1 : index
// CHECK:           scf.for %[[VAL_6:.*]] = %[[VAL_2]] to %[[VAL_4]] step %[[VAL_5]] {
// CHECK:             %[[VAL_7:.*]] = constant 0 : index
// CHECK:             %[[VAL_8:.*]] = memref.load %[[VAL_0]]{{\[}}%[[VAL_6]], %[[VAL_7]]] : memref<?x1xi32>
// CHECK:             %[[VAL_9:.*]] = constant 0 : i32
// CHECK:             %[[VAL_10:.*]] = constant 2 : i32
// CHECK:             %[[VAL_11:.*]] = cmpi sge, %[[VAL_8]], %[[VAL_9]] : i32
// CHECK:             %[[VAL_12:.*]] = cmpi slt, %[[VAL_8]], %[[VAL_10]] : i32
// CHECK:             %[[VAL_13:.*]] = constant 1 : i32
// CHECK:             %[[VAL_14:.*]] = cmpi ult, %[[VAL_8]], %[[VAL_13]] : i32
// CHECK:             %[[VAL_15:.*]] = constant 2.500000e-01 : f64
// CHECK:             %[[VAL_16:.*]] = constant 7.500000e-01 : f64
// CHECK:             %[[VAL_17:.*]] = select %[[VAL_14]], %[[VAL_15]], %[[VAL_16]] : f64
// CHECK:             %[[VAL_18:.*]] = and %[[VAL_11]], %[[VAL_12]] : i1
// CHECK:             %[[VAL_19:.*]] = constant 0.000000e+00 : f64
// CHECK:             %[[VAL_20:.*]] = select %[[VAL_18]], %[[VAL_17]], %[[VAL_19]] : f64
// CHECK:             %[[VAL_21:.*]] = math.log %[[VAL_20]] : f64
// CHECK:             memref.store %[[VAL_21]], %[[VAL_1]]{{\[}}%[[VAL_6]]] : memref<?xf64>
// CHECK:           }
// CHECK:           return
// CHECK:         }

// CHECK-LABEL:   func @spn_kernel(
// CHECK-SAME:                     %[[VAL_0:.*]]: memref<?x1xi32>,
// CHECK-SAME:                     %[[VAL_1:.*]]: memref<?xf64>) {
// CHECK:           %[[VAL_2:.*]] = constant 0 : index
// CHECK:           %[[VAL_3:.*]] = memref.dim %[[VAL_0]], %[[VAL_2]] : memref<?x1xi32>
// CHECK:           %[[VAL_4:.*]] = memref.alloc(%[[VAL_3]]) : memref<?xf64>
// CHECK:           call @task_0(%[[VAL_0]], %[[VAL_4]]) : (memref<?x1xi32>, memref<?xf64>) -> ()
// CHECK:           %[[VAL_5:.*]] = constant 0 : index
// CHECK:           %[[VAL_6:.*]] = memref.dim %[[VAL_4]], %[[VAL_5]] : memref<?xf64>
// CHECK:           %[[VAL_7:.*]] = constant 0 : index
// CHECK:           %[[VAL_8:.*]] = constant 1 : index
// CHECK:           scf.for %[[VAL_9:.*]] = %[[VAL_7]] to %[[VAL_6]] step %[[VAL_8]] {
// CHECK:             %[[VAL_10:.*]] = memref.load %[[VAL_4]]{{\[}}%[[VAL_9]]] : memref<?xf64>
// CHECK:             memref.store %[[VAL_10]], %[[VAL_1]]{{\[}}%[[VAL_9]]] : memref<?xf64>
// CHECK:           }
// CHECK:           return
// CHECK:         }
