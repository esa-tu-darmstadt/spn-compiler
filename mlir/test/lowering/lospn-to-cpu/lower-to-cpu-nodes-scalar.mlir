// RUN: %optcall --convert-lospn-nodes-to-cpu %s | FileCheck %s
// Test (re)generated by regenerate_tests.py.
// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// The script is designed to make adding checks to
// a test case fast, it is *not* designed to be authoritative
// about what constitutes a good test! The CHECK should be
// minimized and named to reflect the test intent.

// CHECK-LABEL:   memref.global "private" constant @histogram_1 : memref<2xf64> = dense<[4.500000e-01, 5.500000e-01]>
// CHECK:         memref.global "private" constant @histogram_0 : memref<2xf64> = dense<[2.500000e-01, 7.500000e-01]>
// CHECK:         memref.global "private" constant @categorical_1 : memref<3xf64> = dense<[2.500000e-01, 6.250000e-01, 1.250000e-01]>
// CHECK:         memref.global "private" constant @categorical_0 : memref<3xf64> = dense<[3.500000e-01, 5.500000e-01, 1.000000e-01]>
// CHECK:         memref.global "private" constant @histogram_vec_1 : memref<2xf64> = dense<[4.500000e-01, 5.500000e-01]>
// CHECK:         memref.global "private" constant @histogram_vec_0 : memref<2xf64> = dense<[2.500000e-01, 7.500000e-01]>
// CHECK:         memref.global "private" constant @categorical_vec_1 : memref<3xf64> = dense<[2.500000e-01, 6.250000e-01, 1.250000e-01]>
// CHECK:         memref.global "private" constant @categorical_vec_0 : memref<3xf64> = dense<[3.500000e-01, 5.500000e-01, 1.000000e-01]>
// RUN: %optcall --convert-lospn-nodes-to-cpu %s | FileCheck %s
module {
  memref.global "private" constant @histogram_vec_1 : memref<2xf64> = dense<[4.500000e-01, 5.500000e-01]>
  memref.global "private" constant @histogram_vec_0 : memref<2xf64> = dense<[2.500000e-01, 7.500000e-01]>
  memref.global "private" constant @categorical_vec_1 : memref<3xf64> = dense<[2.500000e-01, 6.250000e-01, 1.250000e-01]>
  memref.global "private" constant @categorical_vec_0 : memref<3xf64> = dense<[3.500000e-01, 5.500000e-01, 1.000000e-01]>
// CHECK-LABEL:   func.func @vec_task_0(
// CHECK-SAME:                          %[[VAL_0:.*]]: memref<?x6xf64>,
// CHECK-SAME:                          %[[VAL_1:.*]]: memref<1x?xf64>) {
// CHECK:           %[[VAL_2:.*]] = arith.constant 0 : index
// CHECK:           %[[VAL_3:.*]] = memref.dim %[[VAL_0]], %[[VAL_2]] : memref<?x6xf64>
// CHECK:           %[[VAL_4:.*]] = arith.constant 4 : index
// CHECK:           %[[VAL_5:.*]] = arith.remui %[[VAL_3]], %[[VAL_4]] : index
// CHECK:           %[[VAL_6:.*]] = arith.subi %[[VAL_3]], %[[VAL_5]] : index
// CHECK:           %[[VAL_7:.*]] = arith.constant 0 : index
// CHECK:           %[[VAL_8:.*]] = arith.constant 4 : index
// CHECK:           scf.for %[[VAL_9:.*]] = %[[VAL_7]] to %[[VAL_6]] step %[[VAL_8]] {
// CHECK:             %[[VAL_10:.*]] = arith.index_cast %[[VAL_9]] : index to i64
// CHECK:             %[[VAL_11:.*]] = vector.broadcast %[[VAL_10]] : i64 to vector<4xi64>
// CHECK:             %[[VAL_12:.*]] = arith.constant dense<[0, 6, 12, 18]> : vector<4xi64>
// CHECK:             %[[VAL_13:.*]] = arith.constant dense<6> : vector<4xi64>
// CHECK:             %[[VAL_14:.*]] = arith.muli %[[VAL_11]], %[[VAL_13]] : vector<4xi64>
// CHECK:             %[[VAL_15:.*]] = arith.addi %[[VAL_14]], %[[VAL_12]] : vector<4xi64>
// CHECK:             %[[VAL_16:.*]] = arith.constant dense<0.000000e+00> : vector<4xf64>
// CHECK:             %[[VAL_17:.*]] = arith.constant dense<true> : vector<4xi1>
// CHECK:             %[[VAL_18:.*]] = arith.constant 0 : index
// CHECK:             %[[VAL_19:.*]] = memref.dim %[[VAL_0]], %[[VAL_18]] : memref<?x6xf64>
// CHECK:             %[[VAL_20:.*]] = arith.constant 6 : index
// CHECK:             %[[VAL_21:.*]] = arith.muli %[[VAL_19]], %[[VAL_20]] : index
// CHECK:             %[[VAL_22:.*]] = memref.reinterpret_cast %[[VAL_0]] to offset: [0], sizes: {{\[}}%[[VAL_21]]], strides: [1] : memref<?x6xf64> to memref<?xf64>
// CHECK:             %[[VAL_23:.*]] = arith.constant 0 : index
// CHECK:             %[[VAL_24:.*]] = vector.gather %[[VAL_22]]{{\[}}%[[VAL_23]]] {{\[}}%[[VAL_15]]], %[[VAL_17]], %[[VAL_16]] : memref<?xf64>, vector<4xi64>, vector<4xi1>, vector<4xf64> into vector<4xf64>
// CHECK:             %[[VAL_25:.*]] = arith.index_cast %[[VAL_9]] : index to i64
// CHECK:             %[[VAL_26:.*]] = vector.broadcast %[[VAL_25]] : i64 to vector<4xi64>
// CHECK:             %[[VAL_27:.*]] = arith.constant dense<[1, 7, 13, 19]> : vector<4xi64>
// CHECK:             %[[VAL_28:.*]] = arith.constant dense<6> : vector<4xi64>
// CHECK:             %[[VAL_29:.*]] = arith.muli %[[VAL_26]], %[[VAL_28]] : vector<4xi64>
// CHECK:             %[[VAL_30:.*]] = arith.addi %[[VAL_29]], %[[VAL_27]] : vector<4xi64>
// CHECK:             %[[VAL_31:.*]] = arith.constant dense<0.000000e+00> : vector<4xf64>
// CHECK:             %[[VAL_32:.*]] = arith.constant dense<true> : vector<4xi1>
// CHECK:             %[[VAL_33:.*]] = arith.constant 0 : index
// CHECK:             %[[VAL_34:.*]] = memref.dim %[[VAL_0]], %[[VAL_33]] : memref<?x6xf64>
// CHECK:             %[[VAL_35:.*]] = arith.constant 6 : index
// CHECK:             %[[VAL_36:.*]] = arith.muli %[[VAL_34]], %[[VAL_35]] : index
// CHECK:             %[[VAL_37:.*]] = memref.reinterpret_cast %[[VAL_0]] to offset: [0], sizes: {{\[}}%[[VAL_36]]], strides: [1] : memref<?x6xf64> to memref<?xf64>
// CHECK:             %[[VAL_38:.*]] = arith.constant 0 : index
// CHECK:             %[[VAL_39:.*]] = vector.gather %[[VAL_37]]{{\[}}%[[VAL_38]]] {{\[}}%[[VAL_30]]], %[[VAL_32]], %[[VAL_31]] : memref<?xf64>, vector<4xi64>, vector<4xi1>, vector<4xf64> into vector<4xf64>
// CHECK:             %[[VAL_40:.*]] = arith.index_cast %[[VAL_9]] : index to i64
// CHECK:             %[[VAL_41:.*]] = vector.broadcast %[[VAL_40]] : i64 to vector<4xi64>
// CHECK:             %[[VAL_42:.*]] = arith.constant dense<[2, 8, 14, 20]> : vector<4xi64>
// CHECK:             %[[VAL_43:.*]] = arith.constant dense<6> : vector<4xi64>
// CHECK:             %[[VAL_44:.*]] = arith.muli %[[VAL_41]], %[[VAL_43]] : vector<4xi64>
// CHECK:             %[[VAL_45:.*]] = arith.addi %[[VAL_44]], %[[VAL_42]] : vector<4xi64>
// CHECK:             %[[VAL_46:.*]] = arith.constant dense<0.000000e+00> : vector<4xf64>
// CHECK:             %[[VAL_47:.*]] = arith.constant dense<true> : vector<4xi1>
// CHECK:             %[[VAL_48:.*]] = arith.constant 0 : index
// CHECK:             %[[VAL_49:.*]] = memref.dim %[[VAL_0]], %[[VAL_48]] : memref<?x6xf64>
// CHECK:             %[[VAL_50:.*]] = arith.constant 6 : index
// CHECK:             %[[VAL_51:.*]] = arith.muli %[[VAL_49]], %[[VAL_50]] : index
// CHECK:             %[[VAL_52:.*]] = memref.reinterpret_cast %[[VAL_0]] to offset: [0], sizes: {{\[}}%[[VAL_51]]], strides: [1] : memref<?x6xf64> to memref<?xf64>
// CHECK:             %[[VAL_53:.*]] = arith.constant 0 : index
// CHECK:             %[[VAL_54:.*]] = vector.gather %[[VAL_52]]{{\[}}%[[VAL_53]]] {{\[}}%[[VAL_45]]], %[[VAL_47]], %[[VAL_46]] : memref<?xf64>, vector<4xi64>, vector<4xi1>, vector<4xf64> into vector<4xf64>
// CHECK:             %[[VAL_55:.*]] = arith.index_cast %[[VAL_9]] : index to i64
// CHECK:             %[[VAL_56:.*]] = vector.broadcast %[[VAL_55]] : i64 to vector<4xi64>
// CHECK:             %[[VAL_57:.*]] = arith.constant dense<[3, 9, 15, 21]> : vector<4xi64>
// CHECK:             %[[VAL_58:.*]] = arith.constant dense<6> : vector<4xi64>
// CHECK:             %[[VAL_59:.*]] = arith.muli %[[VAL_56]], %[[VAL_58]] : vector<4xi64>
// CHECK:             %[[VAL_60:.*]] = arith.addi %[[VAL_59]], %[[VAL_57]] : vector<4xi64>
// CHECK:             %[[VAL_61:.*]] = arith.constant dense<0.000000e+00> : vector<4xf64>
// CHECK:             %[[VAL_62:.*]] = arith.constant dense<true> : vector<4xi1>
// CHECK:             %[[VAL_63:.*]] = arith.constant 0 : index
// CHECK:             %[[VAL_64:.*]] = memref.dim %[[VAL_0]], %[[VAL_63]] : memref<?x6xf64>
// CHECK:             %[[VAL_65:.*]] = arith.constant 6 : index
// CHECK:             %[[VAL_66:.*]] = arith.muli %[[VAL_64]], %[[VAL_65]] : index
// CHECK:             %[[VAL_67:.*]] = memref.reinterpret_cast %[[VAL_0]] to offset: [0], sizes: {{\[}}%[[VAL_66]]], strides: [1] : memref<?x6xf64> to memref<?xf64>
// CHECK:             %[[VAL_68:.*]] = arith.constant 0 : index
// CHECK:             %[[VAL_69:.*]] = vector.gather %[[VAL_67]]{{\[}}%[[VAL_68]]] {{\[}}%[[VAL_60]]], %[[VAL_62]], %[[VAL_61]] : memref<?xf64>, vector<4xi64>, vector<4xi1>, vector<4xf64> into vector<4xf64>
// CHECK:             %[[VAL_70:.*]] = arith.index_cast %[[VAL_9]] : index to i64
// CHECK:             %[[VAL_71:.*]] = vector.broadcast %[[VAL_70]] : i64 to vector<4xi64>
// CHECK:             %[[VAL_72:.*]] = arith.constant dense<[4, 10, 16, 22]> : vector<4xi64>
// CHECK:             %[[VAL_73:.*]] = arith.constant dense<6> : vector<4xi64>
// CHECK:             %[[VAL_74:.*]] = arith.muli %[[VAL_71]], %[[VAL_73]] : vector<4xi64>
// CHECK:             %[[VAL_75:.*]] = arith.addi %[[VAL_74]], %[[VAL_72]] : vector<4xi64>
// CHECK:             %[[VAL_76:.*]] = arith.constant dense<0.000000e+00> : vector<4xf64>
// CHECK:             %[[VAL_77:.*]] = arith.constant dense<true> : vector<4xi1>
// CHECK:             %[[VAL_78:.*]] = arith.constant 0 : index
// CHECK:             %[[VAL_79:.*]] = memref.dim %[[VAL_0]], %[[VAL_78]] : memref<?x6xf64>
// CHECK:             %[[VAL_80:.*]] = arith.constant 6 : index
// CHECK:             %[[VAL_81:.*]] = arith.muli %[[VAL_79]], %[[VAL_80]] : index
// CHECK:             %[[VAL_82:.*]] = memref.reinterpret_cast %[[VAL_0]] to offset: [0], sizes: {{\[}}%[[VAL_81]]], strides: [1] : memref<?x6xf64> to memref<?xf64>
// CHECK:             %[[VAL_83:.*]] = arith.constant 0 : index
// CHECK:             %[[VAL_84:.*]] = vector.gather %[[VAL_82]]{{\[}}%[[VAL_83]]] {{\[}}%[[VAL_75]]], %[[VAL_77]], %[[VAL_76]] : memref<?xf64>, vector<4xi64>, vector<4xi1>, vector<4xf64> into vector<4xf64>
// CHECK:             %[[VAL_85:.*]] = arith.index_cast %[[VAL_9]] : index to i64
// CHECK:             %[[VAL_86:.*]] = vector.broadcast %[[VAL_85]] : i64 to vector<4xi64>
// CHECK:             %[[VAL_87:.*]] = arith.constant dense<[5, 11, 17, 23]> : vector<4xi64>
// CHECK:             %[[VAL_88:.*]] = arith.constant dense<6> : vector<4xi64>
// CHECK:             %[[VAL_89:.*]] = arith.muli %[[VAL_86]], %[[VAL_88]] : vector<4xi64>
// CHECK:             %[[VAL_90:.*]] = arith.addi %[[VAL_89]], %[[VAL_87]] : vector<4xi64>
// CHECK:             %[[VAL_91:.*]] = arith.constant dense<0.000000e+00> : vector<4xf64>
// CHECK:             %[[VAL_92:.*]] = arith.constant dense<true> : vector<4xi1>
// CHECK:             %[[VAL_93:.*]] = arith.constant 0 : index
// CHECK:             %[[VAL_94:.*]] = memref.dim %[[VAL_0]], %[[VAL_93]] : memref<?x6xf64>
// CHECK:             %[[VAL_95:.*]] = arith.constant 6 : index
// CHECK:             %[[VAL_96:.*]] = arith.muli %[[VAL_94]], %[[VAL_95]] : index
// CHECK:             %[[VAL_97:.*]] = memref.reinterpret_cast %[[VAL_0]] to offset: [0], sizes: {{\[}}%[[VAL_96]]], strides: [1] : memref<?x6xf64> to memref<?xf64>
// CHECK:             %[[VAL_98:.*]] = arith.constant 0 : index
// CHECK:             %[[VAL_99:.*]] = vector.gather %[[VAL_97]]{{\[}}%[[VAL_98]]] {{\[}}%[[VAL_90]]], %[[VAL_92]], %[[VAL_91]] : memref<?xf64>, vector<4xi64>, vector<4xi1>, vector<4xf64> into vector<4xf64>
// CHECK:             %[[VAL_100:.*]] = memref.get_global @categorical_vec_0 : memref<3xf64>
// CHECK:             %[[VAL_101:.*]] = arith.fptoui %[[VAL_24]] : vector<4xf64> to vector<4xi64>
// CHECK:             %[[VAL_102:.*]] = arith.constant dense<0.000000e+00> : vector<4xf64>
// CHECK:             %[[VAL_103:.*]] = arith.constant dense<true> : vector<4xi1>
// CHECK:             %[[VAL_104:.*]] = arith.constant 0 : index
// CHECK:             %[[VAL_105:.*]] = vector.gather %[[VAL_100]]{{\[}}%[[VAL_104]]] {{\[}}%[[VAL_101]]], %[[VAL_103]], %[[VAL_102]] : memref<3xf64>, vector<4xi64>, vector<4xi1>, vector<4xf64> into vector<4xf64>
// CHECK:             %[[VAL_106:.*]] = memref.get_global @categorical_vec_1 : memref<3xf64>
// CHECK:             %[[VAL_107:.*]] = arith.fptoui %[[VAL_39]] : vector<4xf64> to vector<4xi64>
// CHECK:             %[[VAL_108:.*]] = arith.constant dense<0.000000e+00> : vector<4xf64>
// CHECK:             %[[VAL_109:.*]] = arith.constant dense<true> : vector<4xi1>
// CHECK:             %[[VAL_110:.*]] = arith.constant 0 : index
// CHECK:             %[[VAL_111:.*]] = vector.gather %[[VAL_106]]{{\[}}%[[VAL_110]]] {{\[}}%[[VAL_107]]], %[[VAL_109]], %[[VAL_108]] : memref<3xf64>, vector<4xi64>, vector<4xi1>, vector<4xf64> into vector<4xf64>
// CHECK:             %[[VAL_112:.*]] = memref.get_global @histogram_vec_0 : memref<2xf64>
// CHECK:             %[[VAL_113:.*]] = arith.fptoui %[[VAL_54]] : vector<4xf64> to vector<4xi64>
// CHECK:             %[[VAL_114:.*]] = arith.constant dense<0.000000e+00> : vector<4xf64>
// CHECK:             %[[VAL_115:.*]] = arith.constant dense<true> : vector<4xi1>
// CHECK:             %[[VAL_116:.*]] = arith.constant 0 : index
// CHECK:             %[[VAL_117:.*]] = vector.gather %[[VAL_112]]{{\[}}%[[VAL_116]]] {{\[}}%[[VAL_113]]], %[[VAL_115]], %[[VAL_114]] : memref<2xf64>, vector<4xi64>, vector<4xi1>, vector<4xf64> into vector<4xf64>
// CHECK:             %[[VAL_118:.*]] = memref.get_global @histogram_vec_1 : memref<2xf64>
// CHECK:             %[[VAL_119:.*]] = arith.fptoui %[[VAL_69]] : vector<4xf64> to vector<4xi64>
// CHECK:             %[[VAL_120:.*]] = arith.constant dense<0.000000e+00> : vector<4xf64>
// CHECK:             %[[VAL_121:.*]] = arith.constant dense<true> : vector<4xi1>
// CHECK:             %[[VAL_122:.*]] = arith.constant 0 : index
// CHECK:             %[[VAL_123:.*]] = vector.gather %[[VAL_118]]{{\[}}%[[VAL_122]]] {{\[}}%[[VAL_119]]], %[[VAL_121]], %[[VAL_120]] : memref<2xf64>, vector<4xi64>, vector<4xi1>, vector<4xf64> into vector<4xf64>
// CHECK:             %[[VAL_124:.*]] = arith.constant dense<0.3989422804014327> : vector<4xf64>
// CHECK:             %[[VAL_125:.*]] = arith.constant dense<-5.000000e-01> : vector<4xf64>
// CHECK:             %[[VAL_126:.*]] = arith.constant dense<5.000000e-01> : vector<4xf64>
// CHECK:             %[[VAL_127:.*]] = arith.subf %[[VAL_84]], %[[VAL_126]] : vector<4xf64>
// CHECK:             %[[VAL_128:.*]] = arith.mulf %[[VAL_127]], %[[VAL_127]] : vector<4xf64>
// CHECK:             %[[VAL_129:.*]] = arith.mulf %[[VAL_128]], %[[VAL_125]] : vector<4xf64>
// CHECK:             %[[VAL_130:.*]] = math.exp %[[VAL_129]] : vector<4xf64>
// CHECK:             %[[VAL_131:.*]] = arith.mulf %[[VAL_124]], %[[VAL_130]] : vector<4xf64>
// CHECK:             %[[VAL_132:.*]] = arith.constant dense<3.9894228040143269> : vector<4xf64>
// CHECK:             %[[VAL_133:.*]] = arith.constant dense<-49.999999999999993> : vector<4xf64>
// CHECK:             %[[VAL_134:.*]] = arith.constant dense<2.500000e-01> : vector<4xf64>
// CHECK:             %[[VAL_135:.*]] = arith.subf %[[VAL_99]], %[[VAL_134]] : vector<4xf64>
// CHECK:             %[[VAL_136:.*]] = arith.mulf %[[VAL_135]], %[[VAL_135]] : vector<4xf64>
// CHECK:             %[[VAL_137:.*]] = arith.mulf %[[VAL_136]], %[[VAL_133]] : vector<4xf64>
// CHECK:             %[[VAL_138:.*]] = math.exp %[[VAL_137]] : vector<4xf64>
// CHECK:             %[[VAL_139:.*]] = arith.mulf %[[VAL_132]], %[[VAL_138]] : vector<4xf64>
// CHECK:             %[[VAL_140:.*]] = arith.mulf %[[VAL_105]], %[[VAL_111]] : vector<4xf64>
// CHECK:             %[[VAL_141:.*]] = arith.mulf %[[VAL_140]], %[[VAL_117]] : vector<4xf64>
// CHECK:             %[[VAL_142:.*]] = arith.constant dense<1.000000e-01> : vector<4xf64>
// CHECK:             %[[VAL_143:.*]] = arith.mulf %[[VAL_141]], %[[VAL_142]] : vector<4xf64>
// CHECK:             %[[VAL_144:.*]] = arith.mulf %[[VAL_123]], %[[VAL_131]] : vector<4xf64>
// CHECK:             %[[VAL_145:.*]] = arith.mulf %[[VAL_144]], %[[VAL_139]] : vector<4xf64>
// CHECK:             %[[VAL_146:.*]] = arith.constant dense<1.000000e-01> : vector<4xf64>
// CHECK:             %[[VAL_147:.*]] = arith.mulf %[[VAL_145]], %[[VAL_146]] : vector<4xf64>
// CHECK:             %[[VAL_148:.*]] = arith.addf %[[VAL_143]], %[[VAL_147]] : vector<4xf64>
// CHECK:             %[[VAL_149:.*]] = math.log %[[VAL_148]] : vector<4xf64>
// CHECK:             %[[VAL_150:.*]] = arith.constant 0 : index
// CHECK:             vector.transfer_write %[[VAL_149]], %[[VAL_1]]{{\[}}%[[VAL_150]], %[[VAL_9]]] : vector<4xf64>, memref<1x?xf64>
// CHECK:           }
// CHECK:           %[[VAL_151:.*]] = arith.constant 1 : index
// CHECK:           scf.for %[[VAL_152:.*]] = %[[VAL_6]] to %[[VAL_3]] step %[[VAL_151]] {
// CHECK:             %[[VAL_153:.*]] = arith.constant 0 : index
// CHECK:             %[[VAL_154:.*]] = memref.load %[[VAL_0]]{{\[}}%[[VAL_152]], %[[VAL_153]]] : memref<?x6xf64>
// CHECK:             %[[VAL_155:.*]] = arith.constant 1 : index
// CHECK:             %[[VAL_156:.*]] = memref.load %[[VAL_0]]{{\[}}%[[VAL_152]], %[[VAL_155]]] : memref<?x6xf64>
// CHECK:             %[[VAL_157:.*]] = arith.constant 2 : index
// CHECK:             %[[VAL_158:.*]] = memref.load %[[VAL_0]]{{\[}}%[[VAL_152]], %[[VAL_157]]] : memref<?x6xf64>
// CHECK:             %[[VAL_159:.*]] = arith.constant 3 : index
// CHECK:             %[[VAL_160:.*]] = memref.load %[[VAL_0]]{{\[}}%[[VAL_152]], %[[VAL_159]]] : memref<?x6xf64>
// CHECK:             %[[VAL_161:.*]] = arith.constant 4 : index
// CHECK:             %[[VAL_162:.*]] = memref.load %[[VAL_0]]{{\[}}%[[VAL_152]], %[[VAL_161]]] : memref<?x6xf64>
// CHECK:             %[[VAL_163:.*]] = arith.constant 5 : index
// CHECK:             %[[VAL_164:.*]] = memref.load %[[VAL_0]]{{\[}}%[[VAL_152]], %[[VAL_163]]] : memref<?x6xf64>
// CHECK:             %[[VAL_165:.*]] = memref.get_global @categorical_0 : memref<3xf64>
// CHECK:             %[[VAL_166:.*]] = arith.fptoui %[[VAL_154]] : f64 to i64
// CHECK:             %[[VAL_167:.*]] = arith.index_cast %[[VAL_166]] : i64 to index
// CHECK:             %[[VAL_168:.*]] = memref.load %[[VAL_165]]{{\[}}%[[VAL_167]]] : memref<3xf64>
// CHECK:             %[[VAL_169:.*]] = memref.get_global @categorical_1 : memref<3xf64>
// CHECK:             %[[VAL_170:.*]] = arith.fptoui %[[VAL_156]] : f64 to i64
// CHECK:             %[[VAL_171:.*]] = arith.index_cast %[[VAL_170]] : i64 to index
// CHECK:             %[[VAL_172:.*]] = memref.load %[[VAL_169]]{{\[}}%[[VAL_171]]] : memref<3xf64>
// CHECK:             %[[VAL_173:.*]] = memref.get_global @histogram_0 : memref<2xf64>
// CHECK:             %[[VAL_174:.*]] = arith.fptoui %[[VAL_158]] : f64 to i64
// CHECK:             %[[VAL_175:.*]] = arith.index_cast %[[VAL_174]] : i64 to index
// CHECK:             %[[VAL_176:.*]] = memref.load %[[VAL_173]]{{\[}}%[[VAL_175]]] : memref<2xf64>
// CHECK:             %[[VAL_177:.*]] = memref.get_global @histogram_1 : memref<2xf64>
// CHECK:             %[[VAL_178:.*]] = arith.fptoui %[[VAL_160]] : f64 to i64
// CHECK:             %[[VAL_179:.*]] = arith.index_cast %[[VAL_178]] : i64 to index
// CHECK:             %[[VAL_180:.*]] = memref.load %[[VAL_177]]{{\[}}%[[VAL_179]]] : memref<2xf64>
// CHECK:             %[[VAL_181:.*]] = arith.constant 0.3989422804014327 : f64
// CHECK:             %[[VAL_182:.*]] = arith.constant -5.000000e-01 : f64
// CHECK:             %[[VAL_183:.*]] = arith.constant 5.000000e-01 : f64
// CHECK:             %[[VAL_184:.*]] = arith.subf %[[VAL_162]], %[[VAL_183]] : f64
// CHECK:             %[[VAL_185:.*]] = arith.mulf %[[VAL_184]], %[[VAL_184]] : f64
// CHECK:             %[[VAL_186:.*]] = arith.mulf %[[VAL_185]], %[[VAL_182]] : f64
// CHECK:             %[[VAL_187:.*]] = math.exp %[[VAL_186]] : f64
// CHECK:             %[[VAL_188:.*]] = arith.mulf %[[VAL_181]], %[[VAL_187]] : f64
// CHECK:             %[[VAL_189:.*]] = arith.constant 3.9894228040143269 : f64
// CHECK:             %[[VAL_190:.*]] = arith.constant -49.999999999999993 : f64
// CHECK:             %[[VAL_191:.*]] = arith.constant 2.500000e-01 : f64
// CHECK:             %[[VAL_192:.*]] = arith.subf %[[VAL_164]], %[[VAL_191]] : f64
// CHECK:             %[[VAL_193:.*]] = arith.mulf %[[VAL_192]], %[[VAL_192]] : f64
// CHECK:             %[[VAL_194:.*]] = arith.mulf %[[VAL_193]], %[[VAL_190]] : f64
// CHECK:             %[[VAL_195:.*]] = math.exp %[[VAL_194]] : f64
// CHECK:             %[[VAL_196:.*]] = arith.mulf %[[VAL_189]], %[[VAL_195]] : f64
// CHECK:             %[[VAL_197:.*]] = arith.mulf %[[VAL_168]], %[[VAL_172]] : f64
// CHECK:             %[[VAL_198:.*]] = arith.mulf %[[VAL_197]], %[[VAL_176]] : f64
// CHECK:             %[[VAL_199:.*]] = arith.constant 1.000000e-01 : f64
// CHECK:             %[[VAL_200:.*]] = arith.mulf %[[VAL_198]], %[[VAL_199]] : f64
// CHECK:             %[[VAL_201:.*]] = arith.mulf %[[VAL_180]], %[[VAL_188]] : f64
// CHECK:             %[[VAL_202:.*]] = arith.mulf %[[VAL_201]], %[[VAL_196]] : f64
// CHECK:             %[[VAL_203:.*]] = arith.constant 1.000000e-01 : f64
// CHECK:             %[[VAL_204:.*]] = arith.mulf %[[VAL_202]], %[[VAL_203]] : f64
// CHECK:             %[[VAL_205:.*]] = arith.addf %[[VAL_200]], %[[VAL_204]] : f64
// CHECK:             %[[VAL_206:.*]] = math.log %[[VAL_205]] : f64
// CHECK:             %[[VAL_207:.*]] = arith.constant 0 : index
// CHECK:             memref.store %[[VAL_206]], %[[VAL_1]]{{\[}}%[[VAL_207]], %[[VAL_152]]] : memref<1x?xf64>
// CHECK:           }
// CHECK:           return
// CHECK:         }
  func.func @vec_task_0(%arg0: memref<?x6xf64>, %arg1: memref<1x?xf64>) {
    %c0 = arith.constant 0 : index
    %dim = memref.dim %arg0, %c0 : memref<?x6xf64>
    %c4 = arith.constant 4 : index
    %0 = arith.remui %dim, %c4 : index
    %1 = arith.subi %dim, %0 : index
    %c0_0 = arith.constant 0 : index
    %c4_1 = arith.constant 4 : index
    scf.for %arg2 = %c0_0 to %1 step %c4_1 {
      %2 = arith.index_cast %arg2 : index to i64
      %3 = vector.broadcast %2 : i64 to vector<4xi64>
      %cst = arith.constant dense<[0, 6, 12, 18]> : vector<4xi64>
      %cst_2 = arith.constant dense<6> : vector<4xi64>
      %4 = arith.muli %3, %cst_2 : vector<4xi64>
      %5 = arith.addi %4, %cst : vector<4xi64>
      %cst_3 = arith.constant dense<0.000000e+00> : vector<4xf64>
      %cst_4 = arith.constant dense<true> : vector<4xi1>
      %c0_5 = arith.constant 0 : index
      %dim_6 = memref.dim %arg0, %c0_5 : memref<?x6xf64>
      %c6 = arith.constant 6 : index
      %6 = arith.muli %dim_6, %c6 : index
      %reinterpret_cast = memref.reinterpret_cast %arg0 to offset: [0], sizes: [%6], strides: [1] : memref<?x6xf64> to memref<?xf64>
      %c0_7 = arith.constant 0 : index
      %7 = vector.gather %reinterpret_cast[%c0_7] [%5], %cst_4, %cst_3 : memref<?xf64>, vector<4xi64>, vector<4xi1>, vector<4xf64> into vector<4xf64>
      %8 = arith.index_cast %arg2 : index to i64
      %9 = vector.broadcast %8 : i64 to vector<4xi64>
      %cst_8 = arith.constant dense<[1, 7, 13, 19]> : vector<4xi64>
      %cst_9 = arith.constant dense<6> : vector<4xi64>
      %10 = arith.muli %9, %cst_9 : vector<4xi64>
      %11 = arith.addi %10, %cst_8 : vector<4xi64>
      %cst_10 = arith.constant dense<0.000000e+00> : vector<4xf64>
      %cst_11 = arith.constant dense<true> : vector<4xi1>
      %c0_12 = arith.constant 0 : index
      %dim_13 = memref.dim %arg0, %c0_12 : memref<?x6xf64>
      %c6_14 = arith.constant 6 : index
      %12 = arith.muli %dim_13, %c6_14 : index
      %reinterpret_cast_15 = memref.reinterpret_cast %arg0 to offset: [0], sizes: [%12], strides: [1] : memref<?x6xf64> to memref<?xf64>
      %c0_16 = arith.constant 0 : index
      %13 = vector.gather %reinterpret_cast_15[%c0_16] [%11], %cst_11, %cst_10 : memref<?xf64>, vector<4xi64>, vector<4xi1>, vector<4xf64> into vector<4xf64>
      %14 = arith.index_cast %arg2 : index to i64
      %15 = vector.broadcast %14 : i64 to vector<4xi64>
      %cst_17 = arith.constant dense<[2, 8, 14, 20]> : vector<4xi64>
      %cst_18 = arith.constant dense<6> : vector<4xi64>
      %16 = arith.muli %15, %cst_18 : vector<4xi64>
      %17 = arith.addi %16, %cst_17 : vector<4xi64>
      %cst_19 = arith.constant dense<0.000000e+00> : vector<4xf64>
      %cst_20 = arith.constant dense<true> : vector<4xi1>
      %c0_21 = arith.constant 0 : index
      %dim_22 = memref.dim %arg0, %c0_21 : memref<?x6xf64>
      %c6_23 = arith.constant 6 : index
      %18 = arith.muli %dim_22, %c6_23 : index
      %reinterpret_cast_24 = memref.reinterpret_cast %arg0 to offset: [0], sizes: [%18], strides: [1] : memref<?x6xf64> to memref<?xf64>
      %c0_25 = arith.constant 0 : index
      %19 = vector.gather %reinterpret_cast_24[%c0_25] [%17], %cst_20, %cst_19 : memref<?xf64>, vector<4xi64>, vector<4xi1>, vector<4xf64> into vector<4xf64>
      %20 = arith.index_cast %arg2 : index to i64
      %21 = vector.broadcast %20 : i64 to vector<4xi64>
      %cst_26 = arith.constant dense<[3, 9, 15, 21]> : vector<4xi64>
      %cst_27 = arith.constant dense<6> : vector<4xi64>
      %22 = arith.muli %21, %cst_27 : vector<4xi64>
      %23 = arith.addi %22, %cst_26 : vector<4xi64>
      %cst_28 = arith.constant dense<0.000000e+00> : vector<4xf64>
      %cst_29 = arith.constant dense<true> : vector<4xi1>
      %c0_30 = arith.constant 0 : index
      %dim_31 = memref.dim %arg0, %c0_30 : memref<?x6xf64>
      %c6_32 = arith.constant 6 : index
      %24 = arith.muli %dim_31, %c6_32 : index
      %reinterpret_cast_33 = memref.reinterpret_cast %arg0 to offset: [0], sizes: [%24], strides: [1] : memref<?x6xf64> to memref<?xf64>
      %c0_34 = arith.constant 0 : index
      %25 = vector.gather %reinterpret_cast_33[%c0_34] [%23], %cst_29, %cst_28 : memref<?xf64>, vector<4xi64>, vector<4xi1>, vector<4xf64> into vector<4xf64>
      %26 = arith.index_cast %arg2 : index to i64
      %27 = vector.broadcast %26 : i64 to vector<4xi64>
      %cst_35 = arith.constant dense<[4, 10, 16, 22]> : vector<4xi64>
      %cst_36 = arith.constant dense<6> : vector<4xi64>
      %28 = arith.muli %27, %cst_36 : vector<4xi64>
      %29 = arith.addi %28, %cst_35 : vector<4xi64>
      %cst_37 = arith.constant dense<0.000000e+00> : vector<4xf64>
      %cst_38 = arith.constant dense<true> : vector<4xi1>
      %c0_39 = arith.constant 0 : index
      %dim_40 = memref.dim %arg0, %c0_39 : memref<?x6xf64>
      %c6_41 = arith.constant 6 : index
      %30 = arith.muli %dim_40, %c6_41 : index
      %reinterpret_cast_42 = memref.reinterpret_cast %arg0 to offset: [0], sizes: [%30], strides: [1] : memref<?x6xf64> to memref<?xf64>
      %c0_43 = arith.constant 0 : index
      %31 = vector.gather %reinterpret_cast_42[%c0_43] [%29], %cst_38, %cst_37 : memref<?xf64>, vector<4xi64>, vector<4xi1>, vector<4xf64> into vector<4xf64>
      %32 = arith.index_cast %arg2 : index to i64
      %33 = vector.broadcast %32 : i64 to vector<4xi64>
      %cst_44 = arith.constant dense<[5, 11, 17, 23]> : vector<4xi64>
      %cst_45 = arith.constant dense<6> : vector<4xi64>
      %34 = arith.muli %33, %cst_45 : vector<4xi64>
      %35 = arith.addi %34, %cst_44 : vector<4xi64>
      %cst_46 = arith.constant dense<0.000000e+00> : vector<4xf64>
      %cst_47 = arith.constant dense<true> : vector<4xi1>
      %c0_48 = arith.constant 0 : index
      %dim_49 = memref.dim %arg0, %c0_48 : memref<?x6xf64>
      %c6_50 = arith.constant 6 : index
      %36 = arith.muli %dim_49, %c6_50 : index
      %reinterpret_cast_51 = memref.reinterpret_cast %arg0 to offset: [0], sizes: [%36], strides: [1] : memref<?x6xf64> to memref<?xf64>
      %c0_52 = arith.constant 0 : index
      %37 = vector.gather %reinterpret_cast_51[%c0_52] [%35], %cst_47, %cst_46 : memref<?xf64>, vector<4xi64>, vector<4xi1>, vector<4xf64> into vector<4xf64>
      %38 = memref.get_global @categorical_vec_0 : memref<3xf64>
      %39 = arith.fptoui %7 : vector<4xf64> to vector<4xi64>
      %cst_53 = arith.constant dense<0.000000e+00> : vector<4xf64>
      %cst_54 = arith.constant dense<true> : vector<4xi1>
      %c0_55 = arith.constant 0 : index
      %40 = vector.gather %38[%c0_55] [%39], %cst_54, %cst_53 : memref<3xf64>, vector<4xi64>, vector<4xi1>, vector<4xf64> into vector<4xf64>
      %41 = memref.get_global @categorical_vec_1 : memref<3xf64>
      %42 = arith.fptoui %13 : vector<4xf64> to vector<4xi64>
      %cst_56 = arith.constant dense<0.000000e+00> : vector<4xf64>
      %cst_57 = arith.constant dense<true> : vector<4xi1>
      %c0_58 = arith.constant 0 : index
      %43 = vector.gather %41[%c0_58] [%42], %cst_57, %cst_56 : memref<3xf64>, vector<4xi64>, vector<4xi1>, vector<4xf64> into vector<4xf64>
      %44 = memref.get_global @histogram_vec_0 : memref<2xf64>
      %45 = arith.fptoui %19 : vector<4xf64> to vector<4xi64>
      %cst_59 = arith.constant dense<0.000000e+00> : vector<4xf64>
      %cst_60 = arith.constant dense<true> : vector<4xi1>
      %c0_61 = arith.constant 0 : index
      %46 = vector.gather %44[%c0_61] [%45], %cst_60, %cst_59 : memref<2xf64>, vector<4xi64>, vector<4xi1>, vector<4xf64> into vector<4xf64>
      %47 = memref.get_global @histogram_vec_1 : memref<2xf64>
      %48 = arith.fptoui %25 : vector<4xf64> to vector<4xi64>
      %cst_62 = arith.constant dense<0.000000e+00> : vector<4xf64>
      %cst_63 = arith.constant dense<true> : vector<4xi1>
      %c0_64 = arith.constant 0 : index
      %49 = vector.gather %47[%c0_64] [%48], %cst_63, %cst_62 : memref<2xf64>, vector<4xi64>, vector<4xi1>, vector<4xf64> into vector<4xf64>
      %cst_65 = arith.constant dense<0.3989422804014327> : vector<4xf64>
      %cst_66 = arith.constant dense<-5.000000e-01> : vector<4xf64>
      %cst_67 = arith.constant dense<5.000000e-01> : vector<4xf64>
      %50 = arith.subf %31, %cst_67 : vector<4xf64>
      %51 = arith.mulf %50, %50 : vector<4xf64>
      %52 = arith.mulf %51, %cst_66 : vector<4xf64>
      %53 = math.exp %52 : vector<4xf64>
      %54 = arith.mulf %cst_65, %53 : vector<4xf64>
      %cst_68 = arith.constant dense<3.9894228040143269> : vector<4xf64>
      %cst_69 = arith.constant dense<-49.999999999999993> : vector<4xf64>
      %cst_70 = arith.constant dense<2.500000e-01> : vector<4xf64>
      %55 = arith.subf %37, %cst_70 : vector<4xf64>
      %56 = arith.mulf %55, %55 : vector<4xf64>
      %57 = arith.mulf %56, %cst_69 : vector<4xf64>
      %58 = math.exp %57 : vector<4xf64>
      %59 = arith.mulf %cst_68, %58 : vector<4xf64>
      %60 = arith.mulf %40, %43 : vector<4xf64>
      %61 = arith.mulf %60, %46 : vector<4xf64>
      %cst_71 = arith.constant dense<1.000000e-01> : vector<4xf64>
      %62 = arith.mulf %61, %cst_71 : vector<4xf64>
      %63 = arith.mulf %49, %54 : vector<4xf64>
      %64 = arith.mulf %63, %59 : vector<4xf64>
      %cst_72 = arith.constant dense<1.000000e-01> : vector<4xf64>
      %65 = arith.mulf %64, %cst_72 : vector<4xf64>
      %66 = arith.addf %62, %65 : vector<4xf64>
      %67 = math.log %66 : vector<4xf64>
      %c0_73 = arith.constant 0 : index
      vector.transfer_write %67, %arg1[%c0_73, %arg2] : vector<4xf64>, memref<1x?xf64>
    }
    %c1 = arith.constant 1 : index
    scf.for %arg2 = %1 to %dim step %c1 {
      %2 = "lo_spn.batch_read"(%arg0, %arg2) <{staticIndex = 0 : ui32}> : (memref<?x6xf64>, index) -> f64
      %3 = "lo_spn.batch_read"(%arg0, %arg2) <{staticIndex = 1 : ui32}> : (memref<?x6xf64>, index) -> f64
      %4 = "lo_spn.batch_read"(%arg0, %arg2) <{staticIndex = 2 : ui32}> : (memref<?x6xf64>, index) -> f64
      %5 = "lo_spn.batch_read"(%arg0, %arg2) <{staticIndex = 3 : ui32}> : (memref<?x6xf64>, index) -> f64
      %6 = "lo_spn.batch_read"(%arg0, %arg2) <{staticIndex = 4 : ui32}> : (memref<?x6xf64>, index) -> f64
      %7 = "lo_spn.batch_read"(%arg0, %arg2) <{staticIndex = 5 : ui32}> : (memref<?x6xf64>, index) -> f64
      %8 = "lo_spn.categorical"(%2) <{probabilities = [3.500000e-01, 5.500000e-01, 1.000000e-01], supportMarginal = false}> : (f64) -> f64
      %9 = "lo_spn.categorical"(%3) <{probabilities = [2.500000e-01, 6.250000e-01, 1.250000e-01], supportMarginal = false}> : (f64) -> f64
      %10 = "lo_spn.histogram"(%4) <{bucketCount = 2 : ui32, buckets = [#hi_spn.bucket<0 to 1 = 2.500000e-01>, #hi_spn.bucket<1 to 2 = 7.500000e-01>], supportMarginal = false}> : (f64) -> f64
      %11 = "lo_spn.histogram"(%5) <{bucketCount = 2 : ui32, buckets = [#hi_spn.bucket<0 to 1 = 4.500000e-01>, #hi_spn.bucket<1 to 2 = 5.500000e-01>], supportMarginal = false}> : (f64) -> f64
      %12 = "lo_spn.gaussian"(%6) <{mean = 5.000000e-01 : f64, stddev = 1.000000e+00 : f64, supportMarginal = false}> : (f64) -> f64
      %13 = "lo_spn.gaussian"(%7) <{mean = 2.500000e-01 : f64, stddev = 1.000000e-01 : f64, supportMarginal = false}> : (f64) -> f64
      %14 = "lo_spn.mul"(%8, %9) : (f64, f64) -> f64
      %15 = "lo_spn.mul"(%14, %10) : (f64, f64) -> f64
      %16 = "lo_spn.constant"() <{value = 1.000000e-01 : f64}> : () -> f64
      %17 = "lo_spn.mul"(%15, %16) : (f64, f64) -> f64
      %18 = "lo_spn.mul"(%11, %12) : (f64, f64) -> f64
      %19 = "lo_spn.mul"(%18, %13) : (f64, f64) -> f64
      %20 = "lo_spn.constant"() <{value = 1.000000e-01 : f64}> : () -> f64
      %21 = "lo_spn.mul"(%19, %20) : (f64, f64) -> f64
      %22 = "lo_spn.add"(%17, %21) : (f64, f64) -> f64
      %23 = "lo_spn.log"(%22) : (f64) -> f64
      "lo_spn.batch_write"(%arg1, %arg2, %23) <{transposed = true}> : (memref<1x?xf64>, index, f64) -> ()
    }
    return
  }
// CHECK-LABEL:   func.func @spn_vector(
// CHECK-SAME:                          %[[VAL_0:.*]]: memref<?x6xf64>,
// CHECK-SAME:                          %[[VAL_1:.*]]: memref<1x?xf64>) {
// CHECK:           %[[VAL_2:.*]] = arith.constant 0 : index
// CHECK:           %[[VAL_3:.*]] = memref.dim %[[VAL_0]], %[[VAL_2]] : memref<?x6xf64>
// CHECK:           %[[VAL_4:.*]] = memref.alloc(%[[VAL_3]]) : memref<1x?xf64>
// CHECK:           call @vec_task_0(%[[VAL_0]], %[[VAL_4]]) : (memref<?x6xf64>, memref<1x?xf64>) -> ()
// CHECK:           %[[VAL_5:.*]] = arith.constant 1 : index
// CHECK:           %[[VAL_6:.*]] = memref.dim %[[VAL_4]], %[[VAL_5]] : memref<1x?xf64>
// CHECK:           %[[VAL_7:.*]] = arith.constant 0 : index
// CHECK:           %[[VAL_8:.*]] = arith.constant 1 : index
// CHECK:           scf.for %[[VAL_9:.*]] = %[[VAL_7]] to %[[VAL_6]] step %[[VAL_8]] {
// CHECK:             %[[VAL_10:.*]] = arith.constant 0 : index
// CHECK:             %[[VAL_11:.*]] = memref.load %[[VAL_4]]{{\[}}%[[VAL_10]], %[[VAL_9]]] : memref<1x?xf64>
// CHECK:             memref.store %[[VAL_11]], %[[VAL_1]]{{\[}}%[[VAL_10]], %[[VAL_9]]] : memref<1x?xf64>
// CHECK:           }
// CHECK:           return
// CHECK:         }
  func.func @spn_vector(%arg0: memref<?x6xf64>, %arg1: memref<1x?xf64>) {
    %c0 = arith.constant 0 : index
    %dim = memref.dim %arg0, %c0 : memref<?x6xf64>
    %alloc = memref.alloc(%dim) : memref<1x?xf64>
    call @vec_task_0(%arg0, %alloc) : (memref<?x6xf64>, memref<1x?xf64>) -> ()
    "lo_spn.copy"(%alloc, %arg1) : (memref<1x?xf64>, memref<1x?xf64>) -> ()
    "lo_spn.return"() : () -> ()
  }
}

