// RUN: %optcall --vectorize-lospn-nodes %s | FileCheck %s

module  {
  func @vec_task_0(%arg0: memref<?x1xf64>, %arg1: memref<?xf64>) {
    %c0 = constant 0 : index
    %c4 = constant 4 : index
    scf.for %arg2 = %c0 to %c4 step %c4 {
      %0 = "lo_spn.batch_read"(%arg0, %arg2) {sampleIndex = 0 : ui32, vector_width = 4 : i32} : (memref<?x1xf64>, index) -> f64
      %1 = "lo_spn.select"(%0) {input_true_threshold = 1.000000e+00 : f64, supportMarginal = false, val_false = 5.500000e-01 : f64, val_true = 3.500000e-01 : f64, vector_width = 4 : i32} : (f64) -> f64
      "lo_spn.batch_write"(%1, %arg1, %arg2) {vector_width = 4 : i32} : (f64, memref<?xf64>, index) -> ()
    }
    return
  }
}

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py


// CHECK-LABEL:   func @vec_task_0(
// CHECK-SAME:                     %[[VAL_0:.*]]: memref<?x1xf64>,
// CHECK-SAME:                     %[[VAL_1:.*]]: memref<?xf64>) {
// CHECK:           %[[VAL_2:.*]] = constant 0 : index
// CHECK:           %[[VAL_3:.*]] = constant 4 : index
// CHECK:           scf.for %[[VAL_4:.*]] = %[[VAL_2]] to %[[VAL_3]] step %[[VAL_3]] {
// CHECK:             %[[VAL_5:.*]] = index_cast %[[VAL_4]] : index to i64
// CHECK:             %[[VAL_6:.*]] = vector.broadcast %[[VAL_5]] : i64 to vector<4xi64>
// CHECK:             %[[VAL_7:.*]] = constant dense<[0, 1, 2, 3]> : vector<4xi64>
// CHECK:             %[[VAL_8:.*]] = constant dense<1> : vector<4xi64>
// CHECK:             %[[VAL_9:.*]] = muli %[[VAL_6]], %[[VAL_8]] : vector<4xi64>
// CHECK:             %[[VAL_10:.*]] = addi %[[VAL_9]], %[[VAL_7]] : vector<4xi64>
// CHECK:             %[[VAL_11:.*]] = constant dense<0.000000e+00> : vector<4xf64>
// CHECK:             %[[VAL_12:.*]] = constant dense<true> : vector<4xi1>
// CHECK:             %[[VAL_13:.*]] = constant 0 : index
// CHECK:             %[[VAL_14:.*]] = memref.dim %[[VAL_0]], %[[VAL_13]] : memref<?x1xf64>
// CHECK:             %[[VAL_15:.*]] = constant 1 : index
// CHECK:             %[[VAL_16:.*]] = muli %[[VAL_14]], %[[VAL_15]] : index
// CHECK:             %[[VAL_17:.*]] = memref.reinterpret_cast %[[VAL_0]] to offset: [0], sizes: {{\[}}%[[VAL_16]]], strides: [1] : memref<?x1xf64> to memref<?xf64>
// CHECK:             %[[VAL_18:.*]] = constant 0 : index
// CHECK:             %[[VAL_19:.*]] = vector.gather %[[VAL_17]]{{\[}}%[[VAL_18]]] {{\[}}%[[VAL_10]]], %[[VAL_12]], %[[VAL_11]] : memref<?xf64>, vector<4xi64>, vector<4xi1>, vector<4xf64> into vector<4xf64>
// CHECK:             %[[VAL_20:.*]] = constant dense<1.000000e+00> : vector<4xf64>
// CHECK:             %[[VAL_21:.*]] = cmpf ult, %[[VAL_19]], %[[VAL_20]] : vector<4xf64>
// CHECK:             %[[VAL_22:.*]] = constant dense<3.500000e-01> : vector<4xf64>
// CHECK:             %[[VAL_23:.*]] = constant dense<5.500000e-01> : vector<4xf64>
// CHECK:             %[[VAL_24:.*]] = select %[[VAL_21]], %[[VAL_22]], %[[VAL_23]] : vector<4xi1>, vector<4xf64>
// CHECK:             vector.transfer_write %[[VAL_24]], %[[VAL_1]]{{\[}}%[[VAL_4]]] : vector<4xf64>, memref<?xf64>
// CHECK:           }
// CHECK:           return
// CHECK:         }
