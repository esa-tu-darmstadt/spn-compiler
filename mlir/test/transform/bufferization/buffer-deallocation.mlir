// RUN: %optcall --buffer-deallocation %s | FileCheck %s
// Test (re)generated by regenerate_tests.py.
// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// The script is designed to make adding checks to
// a test case fast, it is *not* designed to be authoritative
// about what constitutes a good test! The CHECK should be
// minimized and named to reflect the test intent.

// CHECK-LABEL:   memref.global "private" constant @histogram_1 : memref<2xf64> = dense<[4.500000e-01, 5.500000e-01]>
// CHECK:         memref.global "private" constant @histogram_0 : memref<2xf64> = dense<[2.500000e-01, 7.500000e-01]>
// RUN: %optcall --buffer-deallocation %s | FileCheck %s
module {
  memref.global "private" constant @histogram_1 : memref<2xf64> = dense<[4.500000e-01, 5.500000e-01]>
  memref.global "private" constant @histogram_0 : memref<2xf64> = dense<[2.500000e-01, 7.500000e-01]>
// CHECK-LABEL:   func.func @task_0(
// CHECK-SAME:                      %[[VAL_0:.*]]: memref<?x2xi32>,
// CHECK-SAME:                      %[[VAL_1:.*]]: memref<?xf64>) {
// CHECK:           %[[VAL_2:.*]] = arith.constant 0 : index
// CHECK:           %[[VAL_3:.*]] = arith.constant 0 : index
// CHECK:           %[[VAL_4:.*]] = memref.dim %[[VAL_0]], %[[VAL_3]] : memref<?x2xi32>
// CHECK:           %[[VAL_5:.*]] = arith.constant 1 : index
// CHECK:           scf.for %[[VAL_6:.*]] = %[[VAL_2]] to %[[VAL_4]] step %[[VAL_5]] {
// CHECK:             %[[VAL_7:.*]] = arith.constant 0 : index
// CHECK:             %[[VAL_8:.*]] = memref.load %[[VAL_0]]{{\[}}%[[VAL_6]], %[[VAL_7]]] : memref<?x2xi32>
// CHECK:             %[[VAL_9:.*]] = arith.constant 1 : index
// CHECK:             %[[VAL_10:.*]] = memref.load %[[VAL_0]]{{\[}}%[[VAL_6]], %[[VAL_9]]] : memref<?x2xi32>
// CHECK:             %[[VAL_11:.*]] = memref.get_global @histogram_0 : memref<2xf64>
// CHECK:             %[[VAL_12:.*]] = arith.index_cast %[[VAL_8]] : i32 to index
// CHECK:             %[[VAL_13:.*]] = memref.load %[[VAL_11]]{{\[}}%[[VAL_12]]] : memref<2xf64>
// CHECK:             %[[VAL_14:.*]] = memref.get_global @histogram_1 : memref<2xf64>
// CHECK:             %[[VAL_15:.*]] = arith.index_cast %[[VAL_10]] : i32 to index
// CHECK:             %[[VAL_16:.*]] = memref.load %[[VAL_14]]{{\[}}%[[VAL_15]]] : memref<2xf64>
// CHECK:             %[[VAL_17:.*]] = arith.mulf %[[VAL_13]], %[[VAL_16]] : f64
// CHECK:             %[[VAL_18:.*]] = math.log %[[VAL_17]] : f64
// CHECK:             memref.store %[[VAL_18]], %[[VAL_1]]{{\[}}%[[VAL_6]]] : memref<?xf64>
// CHECK:           }
// CHECK:           return
// CHECK:         }
  func.func @task_0(%arg0: memref<?x2xi32>, %arg1: memref<?xf64>) {
    %c0 = arith.constant 0 : index
    %c0_0 = arith.constant 0 : index
    %dim = memref.dim %arg0, %c0_0 : memref<?x2xi32>
    %c1 = arith.constant 1 : index
    scf.for %arg2 = %c0 to %dim step %c1 {
      %c0_1 = arith.constant 0 : index
      %0 = memref.load %arg0[%arg2, %c0_1] : memref<?x2xi32>
      %c1_2 = arith.constant 1 : index
      %1 = memref.load %arg0[%arg2, %c1_2] : memref<?x2xi32>
      %2 = memref.get_global @histogram_0 : memref<2xf64>
      %3 = arith.index_cast %0 : i32 to index
      %4 = memref.load %2[%3] : memref<2xf64>
      %5 = memref.get_global @histogram_1 : memref<2xf64>
      %6 = arith.index_cast %1 : i32 to index
      %7 = memref.load %5[%6] : memref<2xf64>
      %8 = arith.mulf %4, %7 : f64
      %9 = math.log %8 : f64
      memref.store %9, %arg1[%arg2] : memref<?xf64>
    }
    return
  }
// CHECK-LABEL:   func.func @spn_kernel(
// CHECK-SAME:                          %[[VAL_0:.*]]: memref<?x2xi32>,
// CHECK-SAME:                          %[[VAL_1:.*]]: memref<?xf64>) {
// CHECK:           %[[VAL_2:.*]] = arith.constant 0 : index
// CHECK:           %[[VAL_3:.*]] = memref.dim %[[VAL_0]], %[[VAL_2]] : memref<?x2xi32>
// CHECK:           %[[VAL_4:.*]] = memref.alloc(%[[VAL_3]]) : memref<?xf64>
// CHECK:           call @task_0(%[[VAL_0]], %[[VAL_4]]) : (memref<?x2xi32>, memref<?xf64>) -> ()
// CHECK:           "lo_spn.copy"(%[[VAL_4]], %[[VAL_1]]) : (memref<?xf64>, memref<?xf64>) -> ()
// CHECK:           memref.dealloc %[[VAL_4]] : memref<?xf64>
// CHECK:           return
// CHECK:         }
  func.func @spn_kernel(%arg0: memref<?x2xi32>, %arg1: memref<?xf64>) {
    %c0 = arith.constant 0 : index
    %dim = memref.dim %arg0, %c0 : memref<?x2xi32>
    %alloc = memref.alloc(%dim) : memref<?xf64>
    call @task_0(%arg0, %alloc) : (memref<?x2xi32>, memref<?xf64>) -> ()
    "lo_spn.copy"(%alloc, %arg1) : (memref<?xf64>, memref<?xf64>) -> ()
    return
  }
}

