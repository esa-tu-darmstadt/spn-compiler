// RUN: %optcall --lospn-copy-removal %s | FileCheck %s
// Test (re)generated by regenerate_tests.py.
module {
  "lo_spn.kernel"() <{function_type = (memref<?x2xi32>, memref<1x?xf64>) -> (), sym_name = "spn_cpu"}> ({
  ^bb0(%arg0: memref<?x2xi32>, %arg1: memref<1x?xf64>):
    %c0 = arith.constant 0 : index
    %dim = memref.dim %arg0, %c0 : memref<?x2xi32>
    %alloc = memref.alloc(%dim) : memref<1x?xf64>
    "lo_spn.task"(%arg0, %alloc) <{batchSize = 10 : ui32}> ({
    ^bb0(%arg2: index, %arg3: memref<?x2xi32>, %arg4: memref<1x?xf64>):
      %0 = "lo_spn.batch_read"(%arg3, %arg2) <{staticIndex = 0 : ui32, transposed = false}> : (memref<?x2xi32>, index) -> i32
      %1 = "lo_spn.batch_read"(%arg3, %arg2) <{staticIndex = 1 : ui32, transposed = false}> : (memref<?x2xi32>, index) -> i32
      %2 = "lo_spn.body"(%0, %1) ({
      ^bb0(%arg5: i32, %arg6: i32):
        %3 = "lo_spn.histogram"(%arg5) <{bucketCount = 2 : ui32, buckets = [#hi_spn.bucket<0 to 1 = 2.500000e-01>, #hi_spn.bucket<1 to 2 = 7.500000e-01>], supportMarginal = false}> : (i32) -> f64
        %4 = "lo_spn.histogram"(%arg6) <{bucketCount = 2 : ui32, buckets = [#hi_spn.bucket<0 to 1 = 4.500000e-01>, #hi_spn.bucket<1 to 2 = 5.500000e-01>], supportMarginal = false}> : (i32) -> f64
        %5 = "lo_spn.mul"(%3, %4) : (f64, f64) -> f64
        %6 = "lo_spn.histogram"(%arg5) <{bucketCount = 2 : ui32, buckets = [#hi_spn.bucket<0 to 1 = 3.300000e-01>, #hi_spn.bucket<1 to 2 = 6.700000e-01>], supportMarginal = false}> : (i32) -> f64
        %7 = "lo_spn.histogram"(%arg6) <{bucketCount = 2 : ui32, buckets = [#hi_spn.bucket<0 to 1 = 8.750000e-01>, #hi_spn.bucket<1 to 2 = 1.250000e-01>], supportMarginal = false}> : (i32) -> f64
        %8 = "lo_spn.mul"(%6, %7) : (f64, f64) -> f64
        %9 = "lo_spn.constant"() <{type = f64, value = 3.000000e-01 : f64}> : () -> f64
        %10 = "lo_spn.mul"(%5, %9) : (f64, f64) -> f64
        %11 = "lo_spn.constant"() <{type = f64, value = 0.69999999999999996 : f64}> : () -> f64
        %12 = "lo_spn.mul"(%8, %11) : (f64, f64) -> f64
        %13 = "lo_spn.add"(%10, %12) : (f64, f64) -> f64
        %14 = "lo_spn.log"(%13) : (f64) -> f64
        "lo_spn.yield"(%14) : (f64) -> ()
      }) : (i32, i32) -> f64
      "lo_spn.batch_write"(%arg4, %arg2, %2) <{transposed = true}> : (memref<1x?xf64>, index, f64) -> ()
      "lo_spn.return"() : () -> ()
    }) : (memref<?x2xi32>, memref<1x?xf64>) -> ()
    "lo_spn.copy"(%alloc, %arg1) : (memref<1x?xf64>, memref<1x?xf64>) -> ()
    "lo_spn.return"() : () -> ()
  }) {type = (memref<?x2xi32>, memref<1x?xf64>) -> ()} : () -> ()
}

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// The script is designed to make adding checks to
// a test case fast, it is *not* designed to be authoritative
// about what constitutes a good test! The CHECK should be
// minimized and named to reflect the test intent.



// CHECK-LABEL:   "lo_spn.kernel"() <{function_type = (memref<?x2xi32>, memref<1x?xf64>) -> (), sym_name = "spn_cpu"}> ({
// CHECK:         ^bb0(%[[VAL_0:.*]]: memref<?x2xi32>, %[[VAL_1:.*]]: memref<1x?xf64>):
// CHECK:           "lo_spn.task"(%[[VAL_0]], %[[VAL_1]]) <{batchSize = 10 : ui32}> ({
// CHECK:           ^bb0(%[[VAL_2:.*]]: index, %[[VAL_3:.*]]: memref<?x2xi32>, %[[VAL_4:.*]]: memref<1x?xf64>):
// CHECK:             %[[VAL_5:.*]] = "lo_spn.batch_read"(%[[VAL_3]], %[[VAL_2]]) <{staticIndex = 0 : ui32, transposed = false}> : (memref<?x2xi32>, index) -> i32
// CHECK:             %[[VAL_6:.*]] = "lo_spn.batch_read"(%[[VAL_3]], %[[VAL_2]]) <{staticIndex = 1 : ui32, transposed = false}> : (memref<?x2xi32>, index) -> i32
// CHECK:             %[[VAL_7:.*]] = "lo_spn.body"(%[[VAL_5]], %[[VAL_6]]) ({
// CHECK:             ^bb0(%[[VAL_8:.*]]: i32, %[[VAL_9:.*]]: i32):
// CHECK:               %[[VAL_10:.*]] = "lo_spn.constant"() <{type = f64, value = 0.69999999999999996 : f64}> : () -> f64
// CHECK:               %[[VAL_11:.*]] = "lo_spn.constant"() <{type = f64, value = 3.000000e-01 : f64}> : () -> f64
// CHECK:               %[[VAL_12:.*]] = "lo_spn.histogram"(%[[VAL_8]]) <{bucketCount = 2 : ui32, buckets = [#hi_spn.bucket<0 to 1 = 2.500000e-01>, #hi_spn.bucket<1 to 2 = 7.500000e-01>], supportMarginal = false}> : (i32) -> f64
// CHECK:               %[[VAL_13:.*]] = "lo_spn.histogram"(%[[VAL_9]]) <{bucketCount = 2 : ui32, buckets = [#hi_spn.bucket<0 to 1 = 4.500000e-01>, #hi_spn.bucket<1 to 2 = 5.500000e-01>], supportMarginal = false}> : (i32) -> f64
// CHECK:               %[[VAL_14:.*]] = "lo_spn.mul"(%[[VAL_12]], %[[VAL_13]]) : (f64, f64) -> f64
// CHECK:               %[[VAL_15:.*]] = "lo_spn.histogram"(%[[VAL_8]]) <{bucketCount = 2 : ui32, buckets = [#hi_spn.bucket<0 to 1 = 3.300000e-01>, #hi_spn.bucket<1 to 2 = 6.700000e-01>], supportMarginal = false}> : (i32) -> f64
// CHECK:               %[[VAL_16:.*]] = "lo_spn.histogram"(%[[VAL_9]]) <{bucketCount = 2 : ui32, buckets = [#hi_spn.bucket<0 to 1 = 8.750000e-01>, #hi_spn.bucket<1 to 2 = 1.250000e-01>], supportMarginal = false}> : (i32) -> f64
// CHECK:               %[[VAL_17:.*]] = "lo_spn.mul"(%[[VAL_15]], %[[VAL_16]]) : (f64, f64) -> f64
// CHECK:               %[[VAL_18:.*]] = "lo_spn.mul"(%[[VAL_14]], %[[VAL_11]]) : (f64, f64) -> f64
// CHECK:               %[[VAL_19:.*]] = "lo_spn.mul"(%[[VAL_17]], %[[VAL_10]]) : (f64, f64) -> f64
// CHECK:               %[[VAL_20:.*]] = "lo_spn.add"(%[[VAL_18]], %[[VAL_19]]) : (f64, f64) -> f64
// CHECK:               %[[VAL_21:.*]] = "lo_spn.log"(%[[VAL_20]]) : (f64) -> f64
// CHECK:               "lo_spn.yield"(%[[VAL_21]]) : (f64) -> ()
// CHECK:             }) : (i32, i32) -> f64
// CHECK:             "lo_spn.batch_write"(%[[VAL_4]], %[[VAL_2]], %[[VAL_7]]) <{transposed = true}> : (memref<1x?xf64>, index, f64) -> ()
// CHECK:             "lo_spn.return"() : () -> ()
// CHECK:           }) : (memref<?x2xi32>, memref<1x?xf64>) -> ()
// CHECK:           "lo_spn.return"() : () -> ()
// CHECK:         }) {type = (memref<?x2xi32>, memref<1x?xf64>) -> ()} : () -> ()

