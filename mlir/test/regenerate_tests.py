#!/usr/bin/env python3
"""A script to regenerate the FileCheck statements for the tests in this directory.
"""

import argparse
import os
import subprocess
import shlex


def success(message):
    print("\033[92m" + message + "\033[0m")


def error(message):
    print("\033[91m" + message + "\033[0m")


def get_testfiles(path):
    """Return the absolute filenames of all .mlir files in the given directory or the absolute filename of the given file."""
    if os.path.isdir(path):
        # Recursively search for all .mlir files in the directory.
        testfiles = []
        for root, _, files in os.walk(path):
            for file in files:
                if file.endswith(".mlir"):
                    testfiles.append(os.path.abspath(os.path.join(root, file)))
        return testfiles
    elif os.path.isfile(path) and path.endswith(".mlir"):
        return [os.path.abspath(path)]
    else:
        raise ValueError("The provided path is not a file or directory.")


def getRunCommand(filename):
    """Parses a RUN line that starts with the opt tool and ends with FileCheck and returns the command to run."""
    # Example input: "// RUN: %optcall --vectorize-lospn-nodes %s | foo | FileCheck %s"

    with open(filename, "r") as f:
        runCommand = ""
        line = f.readline(-1)
        if not line.startswith("// RUN:") or not line.endswith("| FileCheck %s\n"):
            return None
        # Remove the "// RUN:" prefix and the FileCheck command.
        line = line[len("// RUN:") :]
        runCommand += line[: -len("| FileCheck %s\n")]
        return runCommand.strip()


def regenerate_testfile(filename, optcall, filecheck, gentestchecks):
    print(f"Regenerating {filename}...")
    runCommand = getRunCommand(filename)

    if runCommand is None:
        print(f"Skipping because it does not begin with a valid RUN line.")
        return

    # First, we run the IR through the opt tool without any passes to get a clean version of the IR.
    optProc = subprocess.run(
        [optcall, filename], stdout=subprocess.PIPE, stderr=subprocess.PIPE
    )
    if optProc.returncode != 0:
        error(f"Failed to run {optcall} to get clean IR:")
        print(optProc.stderr.decode("utf-8"))
        return
    cleanIR = optProc.stdout.decode("utf-8")

    # Write the clean IR to the file to be used as source for the FileCheck generation
    with open(filename, "w") as f:
        f.write("// RUN: ")
        f.write(runCommand)
        f.write(" | FileCheck %s\n")
        f.write(cleanIR)

    # Convert the clean IR with the given run command
    replacedRunCommand = runCommand.replace("%s", filename)
    replacedRunCommand = replacedRunCommand.replace("%optcall", optcall)
    print(replacedRunCommand)
    optProc = subprocess.run(
        shlex.split(replacedRunCommand), stdout=subprocess.PIPE, stderr=subprocess.PIPE
    )
    if optProc.returncode != 0:
        error(f"Failed to run {runCommand} to get converted IR:")
        print(optProc.stderr.decode("utf-8"))
        return
    convertedIR = optProc.stdout.decode("utf-8")

    # Try to generate the FileCheck statements with the --source flag
    genChecksProc = subprocess.run(
        [gentestchecks, "--source", filename],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        input=convertedIR.encode("utf-8"),
    )
    if genChecksProc.returncode != 0:
        # Generating FileCheck statements with the --source flag failed.
        # This can happen if a conversion generates multiple blocks from a single block.
        print(
            f"Failed to generate FileCheck statements with --source flag. Trying without."
        )
        genChecksProc = subprocess.run(
            [gentestchecks],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            input=convertedIR.encode("utf-8"),
        )
        if genChecksProc.returncode != 0:
            error(f"Failed to generate FileCheck statements.")
            return
        fileCheckStatements = genChecksProc.stdout.decode("utf-8")

        # When the source flag is not passed, the generated FileCheck statements do not contain the input IR.
        # Thus, we need to append the input IR to the generated FileCheck statements.
        fileContent = cleanIR + fileCheckStatements
    else:
        # Generating FileCheck statements with the --source flag succeeded.
        fileCheckStatements = genChecksProc.stdout.decode("utf-8")

        # When the source flag is passed, the generated FileCheck statements already contain the input IR.
        fileContent = fileCheckStatements

    # The FileCheck generator seems to have a bug when it comes to custom attributes.
    # Or are we missing something?
    fileContent = fileContent.replace("#[[?]]", "#hi_spn.bucket")

    fileContent = "// Test (re)generated by regenerate_tests.py.\n" + fileContent

    # Write the generated content to the file
    with open(filename, "w") as f:
        f.write("// RUN: ")
        f.write(runCommand)
        f.write(" | FileCheck %s\n")
        f.write(fileContent)
    success(f"Regenerated test file.")


def main():
    parser = argparse.ArgumentParser(
        description=__doc__, formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument(
        "path",
        help="The path to a test file or directory. If a directory is provided, all .mlir files in the directory will be processed.",
        default=".",
        nargs="?",
    )
    parser.add_argument(
        "--optcall",
        help="The path of the mlir-opt binary to use",
        default="spnc-opt",
    )
    parser.add_argument(
        "--filecheck",
        help="The path of the FileCheck binary to use",
        default="FileCheck",
    )
    parser.add_argument(
        "--gentestchecks",
        help="The path of the generate-test-checks.py script to use",
        default="generate-test-checks.py",
    )
    args = parser.parse_args()

    testfiles = get_testfiles(args.path)

    for testfile in testfiles:
        regenerate_testfile(testfile, args.optcall, args.filecheck, args.gentestchecks)


if __name__ == "__main__":
    main()
