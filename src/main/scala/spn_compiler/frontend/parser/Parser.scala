package spn_compiler.frontend.parser

import java.io.File

import fastparse.MultiLineWhitespace._
import fastparse._
import spn_compiler.graph_ir.nodes.{IRGraph, InputVar}

import scala.io.Source

/**
  * Entry point for parsing SPN from textual representation in input strings/files.
  */
object Parser {

  /**
    * Parse an SPN from textual representation in an input string.
    * @param text Input string.
    * @return On success, returns a [[IRGraph]] and a list of sets
    *         of [[InputVar]], with each set representing a
    *         marginalization query, marginalizing the variables
    *         in the set.
    */
  def parseString(text : String) : (IRGraph, List[Set[InputVar]]) = {
    // Parse input text.
    val parseResult = parse(text.trim, spn(_)) match {
      case Parsed.Success(parseTree, _) => parseTree
      case f : Parsed.Failure => throw new RuntimeException("Failed to parse SPN from input: \n"+f.trace().terminalsMsg)
    }
    // Perform identification on resulting parse-tree if the parser was successful.
    new Identification().performIdentification(parseResult)
    parseResult.validate()
    new IRConstruction(parseResult).constructIRGraph
  }

  /**
    * Parse an SPN from textual representation in a file.
    *
    * @param file Input file name.
    * @return On success, returns a [[IRGraph]] and a list of sets
    *         of [[InputVar]], with each set representing a
    *         marginalization query, marginalizing the variables
    *         in the set.
    */
  def parseFile(file : File) : (IRGraph, List[Set[InputVar]]) = parseString(Source.fromFile(file).mkString)

  /*
   * Terminals
   *
   * ID	- Arbitrary string, starting with a letter
   * REAL	- Real number, potentially in scientific notation
   * INT	- Integer number, must not start with '0'
   *
   */
  private def digits[ _ : P]    = P( CharsWhileIn("0-9") )
  private def sign[_ : P]   = P( CharIn("+\\-") )
  private def exponent[_ : P]   = P( CharIn("eE") ~ sign.? ~ digits )
  private def fractional[_ : P] = P( "." ~ digits )
  private def integral [_ : P]    = P( "0" | CharIn("1-9") ~ digits.? )
  // Integer numbers
  private def integer [_ : P]   = P( sign.? ~ integral ).!.map(_.toInt)
  // Real numbers, potentially in scientific notation
  private def real [_ : P]    = P( sign.? ~ integral ~ fractional ~ exponent.?).!.map(_.toDouble)
  // All identifying strings starting with a letter. Strings may only contain letters, digits and underscores.
  private def id [_ : P]    = P( CharsWhile(_.isLetter) ~ CharsWhile(c => c.isLetterOrDigit | c == '_').? ).!

  /*
   * Productions
   */

  // spn := node inputs
  private def spn [_ : P] = P(node ~ inputs ~ marginals )
    .map{case(r, inputs, marginals) => ParseTree(r, inputs, marginals)}

  // node := sumNode | productNode | histogramNode | poissonNode
  private def node [_ : P] : P[ParseTreeNode] = sumNode | productNode | histogramNode | poissonNode

  // weightedOp := REAL '*' ID
  private def weightedOp [_ : P] =
  P( real ~ "*" ~ id ).map{case(d, r) => (d, NodeReferenceParseTree(r))}

  // sumNode := ID 'SumNode' '(' weightedOp (',' weightedOp)* ')' '{' node* '}'
  private def sumNode [_ : P] =
  P( id ~ "SumNode" ~/ "(" ~ weightedOp.rep(sep = ","./) ~ ")" ~ "{" ~ node.rep./ ~ "}" )
      .map{case(i, ops, nodes) => SumNodeParseTree(i, ops.toList, nodes.toList)}

  // productNode := ID 'ProductNode' '(' ID (',' ID)* ')' '{' node* '}'
  private def productNode [_ : P] =
  P( id ~ "ProductNode" ~/ "(" ~ id.rep(sep = ","./) ~ ")" ~ "{" ~ node.rep./ ~ "}" )
      .map{case(i, ops, nodes) => ProductNodeParseTree(i, ops.toList.map(r => NodeReferenceParseTree(r)), nodes.toList)}

  // histogramBreak := INT '.'
  private def histogramBreak [_ : P] = P( integer ~ "." )

  // histogramNode := ID 'Histogram' '(' ID '|' '[' histogramBreak (',' histogramBreak)* ']' ';' '[' REAL (',' REAL)* ']' ')'
  private def histogramNode [_ : P] =
  P( id ~ "Histogram" ~/ "(" ~ id ~ "|" ~ "[" ~ histogramBreak.rep(sep = ","./) ~ "]" ~ ";" ~ "[" ~ real.rep(sep = ","./) ~ "]" ~ ")" )
      .map{case(i, v, breaks, values) => HistogramNodeParseTree(i, NodeReferenceParseTree(v), breaks.toList, values.toList)}

  // poissonNode := ID 'P' '(' ID '|' 'lambda' '=' REAL ')'
  private def poissonNode [_ : P] =
  P( id ~ "P" ~/ "(" ~ id ~ "|" ~ "lambda" ~ "=" ~ real ~ ")" )
      .map{case(i, v, l) => PoissonNodeParseTree(i, NodeReferenceParseTree(v), l)}

  // inputs := '#' ID (';' ID)*
  private def inputs [_ : P] =
    P( "#" ~ id.rep(sep = ";")).map(l => l.toList.map(v => InputVariableParseTree(v, l.indexOf(v))))

  // marginalization := '#' ID (';' ID)*
  private def marginalization [_ : P] =
    P( ":" ~ id.rep(sep = ";")).map(l => Set(l.toList.map(v => NodeReferenceParseTree(v)):_*))

  // marginals := marginals*
  private def marginals [_ : P] =
    P(marginalization.rep).map(_.toList)

}
